/*------------------------------------*\
 Site Specific JS
\*------------------------------------*/
WebFontConfig = {
    google: {
        families: [ "Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800:latin" ]
    }
};

(function() {
    var wf = document.createElement("script");
    wf.src = ("https:" == document.location.protocol ? "https" : "http") + "://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js";
    wf.type = "text/javascript";
    wf.async = "true";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(wf, s);
})();

WebFontConfig = {
    google: {
        families: [ "Merriweather:400,300,300italic,400italic,700,700italic:latin" ]
    }
};

(function() {
    var wf = document.createElement("script");
    wf.src = ("https:" == document.location.protocol ? "https" : "http") + "://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js";
    wf.type = "text/javascript";
    wf.async = "true";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(wf, s);
})();

(function($, window, document, undefined) {
    $.fn.doubleTapToGo = function(params) {
        if (!("ontouchstart" in window) && !navigator.msMaxTouchPoints && !navigator.userAgent.toLowerCase().match(/windows phone os 7/i)) return false;
        this.each(function() {
            var curItem = false;
            $(this).on("click", function(e) {
                var item = $(this);
                if (item[0] != curItem[0]) {
                    e.preventDefault();
                    curItem = item;
                }
            });
            $(document).on("click touchstart MSPointerDown", function(e) {
                var resetItem = true, parents = $(e.target).parents();
                for (var i = 0; i < parents.length; i++) if (parents[i] == curItem[0]) resetItem = false;
                if (resetItem) curItem = false;
            });
        });
        return this;
    };
})(jQuery, window, document);

/**
 * fullPage 2.6.4
 * https://github.com/alvarotrigo/fullPage.js
 * MIT licensed
 *
 * Copyright (C) 2015 alvarotrigo.com - A project by Alvaro Trigo
 */
(function($, window, document, Math, undefined) {
    "use strict";
    // keeping central set of classnames and selectors
    var WRAPPER = "fullpage-wrapper";
    var WRAPPER_SEL = "." + WRAPPER;
    // slimscroll
    var SCROLLABLE = "fp-scrollable";
    var SCROLLABLE_SEL = "." + SCROLLABLE;
    var SLIMSCROLL_BAR_SEL = ".slimScrollBar";
    var SLIMSCROLL_RAIL_SEL = ".slimScrollRail";
    // util
    var RESPONSIVE = "fp-responsive";
    var NO_TRANSITION = "fp-notransition";
    var DESTROYED = "fp-destroyed";
    var ENABLED = "fp-enabled";
    var VIEWING_PREFIX = "fp-viewing";
    var ACTIVE = "active";
    var ACTIVE_SEL = "." + ACTIVE;
    // section
    var SECTION_DEFAULT_SEL = ".section";
    var SECTION = "fp-section";
    var SECTION_SEL = "." + SECTION;
    var SECTION_ACTIVE_SEL = SECTION_SEL + ACTIVE_SEL;
    var SECTION_FIRST_SEL = SECTION_SEL + ":first";
    var SECTION_LAST_SEL = SECTION_SEL + ":last";
    var TABLE_CELL = "fp-tableCell";
    var TABLE_CELL_SEL = "." + TABLE_CELL;
    // section nav
    var SECTION_NAV = "fp-nav";
    var SECTION_NAV_SEL = "#" + SECTION_NAV;
    var SECTION_NAV_TOOLTIP = "fp-tooltip";
    var SHOW_ACTIVE_TOOLTIP = "fp-show-active";
    // slide
    var SLIDE_DEFAULT_SEL = ".slide";
    var SLIDE = "fp-slide";
    var SLIDE_SEL = "." + SLIDE;
    var SLIDE_ACTIVE_SEL = SLIDE_SEL + ACTIVE_SEL;
    var SLIDES_WRAPPER = "fp-slides";
    var SLIDES_WRAPPER_SEL = "." + SLIDES_WRAPPER;
    var SLIDES_CONTAINER = "fp-slidesContainer";
    var SLIDES_CONTAINER_SEL = "." + SLIDES_CONTAINER;
    var TABLE = "fp-table";
    // slide nav
    var SLIDES_NAV = "fp-slidesNav";
    var SLIDES_NAV_SEL = "." + SLIDES_NAV;
    var SLIDES_NAV_LINK_SEL = SLIDES_NAV_SEL + " a";
    var SLIDES_ARROW = "fp-controlArrow";
    var SLIDES_ARROW_SEL = "." + SLIDES_ARROW;
    var SLIDES_PREV = "fp-prev";
    var SLIDES_PREV_SEL = "." + SLIDES_PREV;
    var SLIDES_ARROW_PREV = SLIDES_ARROW + " " + SLIDES_PREV;
    var SLIDES_ARROW_PREV_SEL = SLIDES_ARROW_SEL + SLIDES_PREV_SEL;
    var SLIDES_NEXT = "fp-next";
    var SLIDES_NEXT_SEL = "." + SLIDES_NEXT;
    var SLIDES_ARROW_NEXT = SLIDES_ARROW + " " + SLIDES_NEXT;
    var SLIDES_ARROW_NEXT_SEL = SLIDES_ARROW_SEL + SLIDES_NEXT_SEL;
    var $window = $(window);
    var $document = $(document);
    $.fn.fullpage = function(options) {
        // common jQuery objects
        var $htmlBody = $("html, body");
        var $body = $("body");
        var FP = $.fn.fullpage;
        // Create some defaults, extending them with any options that were provided
        options = $.extend({
            //navigation
            menu: false,
            anchors: [],
            navigation: false,
            navigationPosition: "right",
            navigationTooltips: [],
            showActiveTooltip: false,
            slidesNavigation: false,
            slidesNavPosition: "bottom",
            scrollBar: false,
            //scrolling
            css3: true,
            scrollingSpeed: 700,
            autoScrolling: true,
            fitToSection: true,
            easing: "easeInOutCubic",
            easingcss3: "ease",
            loopBottom: false,
            loopTop: false,
            loopHorizontal: true,
            continuousVertical: false,
            normalScrollElements: null,
            scrollOverflow: false,
            touchSensitivity: 5,
            normalScrollElementTouchThreshold: 5,
            //Accessibility
            keyboardScrolling: true,
            animateAnchor: true,
            recordHistory: true,
            //design
            controlArrows: true,
            controlArrowColor: "#fff",
            verticalCentered: true,
            resize: false,
            sectionsColor: [],
            paddingTop: 0,
            paddingBottom: 0,
            fixedElements: null,
            responsive: 0,
            //Custom selectors
            sectionSelector: SECTION_DEFAULT_SEL,
            slideSelector: SLIDE_DEFAULT_SEL,
            //events
            afterLoad: null,
            onLeave: null,
            afterRender: null,
            afterResize: null,
            afterReBuild: null,
            afterSlideLoad: null,
            onSlideLeave: null
        }, options);
        displayWarnings();
        //easeInOutCubic animation included in the plugin
        $.extend($.easing, {
            easeInOutCubic: function(x, t, b, c, d) {
                if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t + 2) + b;
            }
        });
        //TO BE REMOVED in future versions. Maintained temporaly for backwards compatibility.
        $.extend($.easing, {
            easeInQuart: function(x, t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            }
        });
        FP.setAutoScrolling = function(value, type) {
            setVariableState("autoScrolling", value, type);
            var element = $(SECTION_ACTIVE_SEL);
            if (options.autoScrolling && !options.scrollBar) {
                $htmlBody.css({
                    overflow: "hidden",
                    height: "100%"
                });
                FP.setRecordHistory(options.recordHistory, "internal");
                //for IE touch devices
                container.css({
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                });
                if (element.length) {
                    //moving the container up
                    silentScroll(element.position().top);
                }
            } else {
                $htmlBody.css({
                    overflow: "visible",
                    height: "initial"
                });
                FP.setRecordHistory(false, "internal");
                //for IE touch devices
                container.css({
                    "-ms-touch-action": "",
                    "touch-action": ""
                });
                silentScroll(0);
                //scrolling the page to the section with no animation
                if (element.length) {
                    $htmlBody.scrollTop(element.position().top);
                }
            }
        };
        /**
        * Defines wheter to record the history for each hash change in the URL.
        */
        FP.setRecordHistory = function(value, type) {
            setVariableState("recordHistory", value, type);
        };
        /**
        * Defines the scrolling speed
        */
        FP.setScrollingSpeed = function(value, type) {
            setVariableState("scrollingSpeed", value, type);
        };
        /**
        * Sets fitToSection
        */
        FP.setFitToSection = function(value, type) {
            setVariableState("fitToSection", value, type);
        };
        /**
        * Adds or remove the possiblity of scrolling through sections by using the mouse wheel or the trackpad.
        */
        FP.setMouseWheelScrolling = function(value) {
            if (value) {
                addMouseWheelHandler();
            } else {
                removeMouseWheelHandler();
            }
        };
        /**
        * Adds or remove the possiblity of scrolling through sections by using the mouse wheel/trackpad or touch gestures.
        * Optionally a second parameter can be used to specify the direction for which the action will be applied.
        *
        * @param directions string containing the direction or directions separated by comma.
        */
        FP.setAllowScrolling = function(value, directions) {
            if (typeof directions != "undefined") {
                directions = directions.replace(/ /g, "").split(",");
                $.each(directions, function(index, direction) {
                    setIsScrollable(value, direction);
                });
            } else if (value) {
                FP.setMouseWheelScrolling(true);
                addTouchHandler();
            } else {
                FP.setMouseWheelScrolling(false);
                removeTouchHandler();
            }
        };
        /**
        * Adds or remove the possiblity of scrolling through sections by using the keyboard arrow keys
        */
        FP.setKeyboardScrolling = function(value) {
            options.keyboardScrolling = value;
        };
        FP.moveSectionUp = function() {
            var prev = $(SECTION_ACTIVE_SEL).prev(SECTION_SEL);
            //looping to the bottom if there's no more sections above
            if (!prev.length && (options.loopTop || options.continuousVertical)) {
                prev = $(SECTION_SEL).last();
            }
            if (prev.length) {
                scrollPage(prev, null, true);
            }
        };
        FP.moveSectionDown = function() {
            var next = $(SECTION_ACTIVE_SEL).next(SECTION_SEL);
            //looping to the top if there's no more sections below
            if (!next.length && (options.loopBottom || options.continuousVertical)) {
                next = $(SECTION_SEL).first();
            }
            if (next.length) {
                scrollPage(next, null, false);
            }
        };
        FP.moveTo = function(section, slide) {
            var destiny = "";
            if (isNaN(section)) {
                destiny = $('[data-anchor="' + section + '"]');
            } else {
                destiny = $(SECTION_SEL).eq(section - 1);
            }
            if (typeof slide !== "undefined") {
                scrollPageAndSlide(section, slide);
            } else if (destiny.length > 0) {
                scrollPage(destiny);
            }
        };
        FP.moveSlideRight = function() {
            moveSlide("next");
        };
        FP.moveSlideLeft = function() {
            moveSlide("prev");
        };
        /**
         * When resizing is finished, we adjust the slides sizes and positions
         */
        FP.reBuild = function(resizing) {
            if (container.hasClass(DESTROYED)) {
                return;
            }
            //nothing to do if the plugin was destroyed
            isResizing = true;
            var windowsWidth = $window.width();
            windowsHeight = $window.height();
            //updating global var
            //text and images resizing
            if (options.resize) {
                resizeMe(windowsHeight, windowsWidth);
            }
            $(SECTION_SEL).each(function() {
                var slidesWrap = $(this).find(SLIDES_WRAPPER_SEL);
                var slides = $(this).find(SLIDE_SEL);
                //adjusting the height of the table-cell for IE and Firefox
                if (options.verticalCentered) {
                    $(this).find(TABLE_CELL_SEL).css("height", getTableHeight($(this)) + "px");
                }
                $(this).css("height", windowsHeight + "px");
                //resizing the scrolling divs
                if (options.scrollOverflow) {
                    if (slides.length) {
                        slides.each(function() {
                            createSlimScrolling($(this));
                        });
                    } else {
                        createSlimScrolling($(this));
                    }
                }
                //adjusting the position fo the FULL WIDTH slides...
                if (slides.length > 1) {
                    landscapeScroll(slidesWrap, slidesWrap.find(SLIDE_ACTIVE_SEL));
                }
            });
            var activeSection = $(SECTION_ACTIVE_SEL);
            //isn't it the first section?
            if (activeSection.index(SECTION_SEL)) {
                //adjusting the position for the current section
                scrollPage(activeSection);
            }
            isResizing = false;
            $.isFunction(options.afterResize) && resizing && options.afterResize.call(container);
            $.isFunction(options.afterReBuild) && !resizing && options.afterReBuild.call(container);
        };
        //flag to avoid very fast sliding for landscape sliders
        var slideMoving = false;
        var isTouchDevice = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|playbook|silk|BlackBerry|BB10|Windows Phone|Tizen|Bada|webOS|IEMobile|Opera Mini)/);
        var isTouch = "ontouchstart" in window || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints;
        var container = $(this);
        var windowsHeight = $window.height();
        var isResizing = false;
        var lastScrolledDestiny;
        var lastScrolledSlide;
        var canScroll = true;
        var scrollings = [];
        var nav;
        var isScrollAllowed = {
            up: true,
            down: true,
            left: true,
            right: true
        };
        var originals = $.extend(true, {}, options);
        //deep copy
        if ($(this).length) {
            container.css({
                height: "100%",
                position: "relative"
            });
            //adding a class to recognize the container internally in the code
            container.addClass(WRAPPER);
            $("html").addClass(ENABLED);
        } else {
            showError("error", "Error! Fullpage.js needs to be initialized with a selector. For example: $('#myContainer').fullpage();");
        }
        //if css3 is not supported, it will use jQuery animations
        if (options.css3) {
            options.css3 = support3d();
        }
        FP.setAllowScrolling(true);
        container.removeClass(DESTROYED);
        //in case it was destroyed before initilizing it again
        //adding internal class names to void problem with common ones
        $(options.sectionSelector).each(function() {
            $(this).addClass(SECTION);
        });
        $(options.slideSelector).each(function() {
            $(this).addClass(SLIDE);
        });
        //creating the navigation dots
        if (options.navigation) {
            addVerticalNavigation();
        }
        $(SECTION_SEL).each(function(index) {
            var that = $(this);
            var slides = $(this).find(SLIDE_SEL);
            var numSlides = slides.length;
            //if no active section is defined, the 1st one will be the default one
            if (!index && $(SECTION_ACTIVE_SEL).length === 0) {
                $(this).addClass(ACTIVE);
            }
            $(this).css("height", windowsHeight + "px");
            if (options.paddingTop) {
                $(this).css("padding-top", options.paddingTop);
            }
            if (options.paddingBottom) {
                $(this).css("padding-bottom", options.paddingBottom);
            }
            if (typeof options.sectionsColor[index] !== "undefined") {
                $(this).css("background-color", options.sectionsColor[index]);
            }
            if (typeof options.anchors[index] !== "undefined") {
                $(this).attr("data-anchor", options.anchors[index]);
                //activating the menu / nav element on load
                if ($(this).hasClass(ACTIVE)) {
                    activateMenuAndNav(options.anchors[index], index);
                }
            }
            // if there's any slide
            if (numSlides > 0) {
                var sliderWidth = numSlides * 100;
                var slideWidth = 100 / numSlides;
                slides.wrapAll('<div class="' + SLIDES_CONTAINER + '" />');
                slides.parent().wrap('<div class="' + SLIDES_WRAPPER + '" />');
                $(this).find(SLIDES_CONTAINER_SEL).css("width", sliderWidth + "%");
                if (options.controlArrows && numSlides > 1) {
                    createSlideArrows($(this));
                }
                if (options.slidesNavigation) {
                    addSlidesNavigation($(this), numSlides);
                }
                slides.each(function(index) {
                    $(this).css("width", slideWidth + "%");
                    if (options.verticalCentered) {
                        addTableClass($(this));
                    }
                });
                var startingSlide = that.find(SLIDE_ACTIVE_SEL);
                //if the slide won#t be an starting point, the default will be the first one
                if (!startingSlide.length) {
                    slides.eq(0).addClass(ACTIVE);
                } else {
                    silentLandscapeScroll(startingSlide);
                }
            } else {
                if (options.verticalCentered) {
                    addTableClass($(this));
                }
            }
        }).promise().done(function() {
            FP.setAutoScrolling(options.autoScrolling, "internal");
            //the starting point is a slide?
            var activeSlide = $(SECTION_ACTIVE_SEL).find(SLIDE_ACTIVE_SEL);
            //the active section isn't the first one? Is not the first slide of the first section? Then we load that section/slide by default.
            if (activeSlide.length && ($(SECTION_ACTIVE_SEL).index(SECTION_SEL) !== 0 || $(SECTION_ACTIVE_SEL).index(SECTION_SEL) === 0 && activeSlide.index() !== 0)) {
                silentLandscapeScroll(activeSlide);
            }
            //fixed elements need to be moved out of the plugin container due to problems with CSS3.
            if (options.fixedElements && options.css3) {
                $(options.fixedElements).appendTo($body);
            }
            //vertical centered of the navigation + first bullet active
            if (options.navigation) {
                nav.css("margin-top", "-" + nav.height() / 2 + "px");
                nav.find("li").eq($(SECTION_ACTIVE_SEL).index(SECTION_SEL)).find("a").addClass(ACTIVE);
            }
            //moving the menu outside the main container if it is inside (avoid problems with fixed positions when using CSS3 tranforms)
            if (options.menu && options.css3 && $(options.menu).closest(WRAPPER_SEL).length) {
                $(options.menu).appendTo($body);
            }
            if (options.scrollOverflow) {
                if (document.readyState === "complete") {
                    createSlimScrollingHandler();
                }
                //after DOM and images are loaded
                $window.on("load", createSlimScrollingHandler);
            } else {
                $.isFunction(options.afterRender) && options.afterRender.call(container);
            }
            responsive();
            //for animateAnchor:false
            if (!options.animateAnchor) {
                //getting the anchor link in the URL and deleting the `#`
                var value = window.location.hash.replace("#", "").split("/");
                var destiny = value[0];
                if (destiny.length) {
                    var section = $('[data-anchor="' + destiny + '"]');
                    if (section.length) {
                        if (options.autoScrolling) {
                            silentScroll(section.position().top);
                        } else {
                            silentScroll(0);
                            //scrolling the page to the section with no animation
                            $htmlBody.scrollTop(section.position().top);
                        }
                        activateMenuAndNav(destiny, null);
                        $.isFunction(options.afterLoad) && options.afterLoad.call(section, destiny, section.index(SECTION_SEL) + 1);
                        //updating the active class
                        section.addClass(ACTIVE).siblings().removeClass(ACTIVE);
                    }
                }
            }
            //setting the class for the body element
            setBodyClass();
            $window.on("load", function() {
                scrollToAnchor();
            });
        });
        /**
        * Creates the control arrows for the given section
        */
        function createSlideArrows(section) {
            section.find(SLIDES_WRAPPER_SEL).after('<div class="' + SLIDES_ARROW_PREV + '"></div><div class="' + SLIDES_ARROW_NEXT + '"></div>');
            if (options.controlArrowColor != "#fff") {
                section.find(SLIDES_ARROW_NEXT_SEL).css("border-color", "transparent transparent transparent " + options.controlArrowColor);
                section.find(SLIDES_ARROW_PREV_SEL).css("border-color", "transparent " + options.controlArrowColor + " transparent transparent");
            }
            if (!options.loopHorizontal) {
                section.find(SLIDES_ARROW_PREV_SEL).hide();
            }
        }
        /**
        * Creates a vertical navigation bar.
        */
        function addVerticalNavigation() {
            $body.append('<div id="' + SECTION_NAV + '"><ul></ul></div>');
            nav = $(SECTION_NAV_SEL);
            nav.addClass(function() {
                return options.showActiveTooltip ? SHOW_ACTIVE_TOOLTIP + " " + options.navigationPosition : options.navigationPosition;
            });
            for (var i = 0; i < $(SECTION_SEL).length; i++) {
                var link = "";
                if (options.anchors.length) {
                    link = options.anchors[i];
                }
                var li = '<li><a href="#' + link + '"><span></span></a>';
                // Only add tooltip if needed (defined by user)
                var tooltip = options.navigationTooltips[i];
                if (typeof tooltip !== "undefined" && tooltip !== "") {
                    li += '<div class="' + SECTION_NAV_TOOLTIP + " " + options.navigationPosition + '">' + tooltip + "</div>";
                }
                li += "</li>";
                nav.find("ul").append(li);
            }
        }
        function createSlimScrollingHandler() {
            $(SECTION_SEL).each(function() {
                var slides = $(this).find(SLIDE_SEL);
                if (slides.length) {
                    slides.each(function() {
                        createSlimScrolling($(this));
                    });
                } else {
                    createSlimScrolling($(this));
                }
            });
            $.isFunction(options.afterRender) && options.afterRender.call(this);
        }
        var scrollId;
        var scrollId2;
        var isScrolling = false;
        //when scrolling...
        $window.on("scroll", scrollHandler);
        function scrollHandler() {
            var currentSection;
            if (!options.autoScrolling || options.scrollBar) {
                var currentScroll = $window.scrollTop();
                var visibleSectionIndex = 0;
                var initial = Math.abs(currentScroll - document.querySelectorAll(SECTION_SEL)[0].offsetTop);
                //taking the section which is showing more content in the viewport
                var sections = document.querySelectorAll(SECTION_SEL);
                for (var i = 0; i < sections.length; ++i) {
                    var section = sections[i];
                    var current = Math.abs(currentScroll - section.offsetTop);
                    if (current < initial) {
                        visibleSectionIndex = i;
                        initial = current;
                    }
                }
                //geting the last one, the current one on the screen
                currentSection = $(sections).eq(visibleSectionIndex);
            }
            if (!options.autoScrolling || options.scrollBar) {
                //executing only once the first time we reach the section
                if (!currentSection.hasClass(ACTIVE)) {
                    isScrolling = true;
                    var leavingSection = $(SECTION_ACTIVE_SEL);
                    var leavingSectionIndex = leavingSection.index(SECTION_SEL) + 1;
                    var yMovement = getYmovement(currentSection);
                    var anchorLink = currentSection.data("anchor");
                    var sectionIndex = currentSection.index(SECTION_SEL) + 1;
                    var activeSlide = currentSection.find(SLIDE_ACTIVE_SEL);
                    if (activeSlide.length) {
                        var slideAnchorLink = activeSlide.data("anchor");
                        var slideIndex = activeSlide.index();
                    }
                    if (canScroll) {
                        currentSection.addClass(ACTIVE).siblings().removeClass(ACTIVE);
                        $.isFunction(options.onLeave) && options.onLeave.call(leavingSection, leavingSectionIndex, sectionIndex, yMovement);
                        $.isFunction(options.afterLoad) && options.afterLoad.call(currentSection, anchorLink, sectionIndex);
                        activateMenuAndNav(anchorLink, sectionIndex - 1);
                        if (options.anchors.length) {
                            //needed to enter in hashChange event when using the menu with anchor links
                            lastScrolledDestiny = anchorLink;
                            setState(slideIndex, slideAnchorLink, anchorLink, sectionIndex);
                        }
                    }
                    //small timeout in order to avoid entering in hashChange event when scrolling is not finished yet
                    clearTimeout(scrollId);
                    scrollId = setTimeout(function() {
                        isScrolling = false;
                    }, 100);
                }
                if (options.fitToSection) {
                    //for the auto adjust of the viewport to fit a whole section
                    clearTimeout(scrollId2);
                    scrollId2 = setTimeout(function() {
                        if (canScroll) {
                            //allows to scroll to an active section and
                            //if the section is already active, we prevent firing callbacks
                            if ($(SECTION_ACTIVE_SEL).is(currentSection)) {
                                isResizing = true;
                            }
                            scrollPage(currentSection);
                            isResizing = false;
                        }
                    }, 1e3);
                }
            }
        }
        /**
        * Determines whether the active section or slide is scrollable through and scrolling bar
        */
        function isScrollable(activeSection) {
            //if there are landscape slides, we check if the scrolling bar is in the current one or not
            if (activeSection.find(SLIDES_WRAPPER_SEL).length) {
                return activeSection.find(SLIDE_ACTIVE_SEL).find(SCROLLABLE_SEL);
            }
            return activeSection.find(SCROLLABLE_SEL);
        }
        /**
        * Determines the way of scrolling up or down:
        * by 'automatically' scrolling a section or by using the default and normal scrolling.
        */
        function scrolling(type, scrollable) {
            if (!isScrollAllowed[type]) {
                return;
            }
            var check, scrollSection;
            if (type == "down") {
                check = "bottom";
                scrollSection = FP.moveSectionDown;
            } else {
                check = "top";
                scrollSection = FP.moveSectionUp;
            }
            if (scrollable.length > 0) {
                //is the scrollbar at the start/end of the scroll?
                if (isScrolled(check, scrollable)) {
                    scrollSection();
                } else {
                    return true;
                }
            } else {
                // moved up/down
                scrollSection();
            }
        }
        var touchStartY = 0;
        var touchStartX = 0;
        var touchEndY = 0;
        var touchEndX = 0;
        /* Detecting touch events

        * As we are changing the top property of the page on scrolling, we can not use the traditional way to detect it.
        * This way, the touchstart and the touch moves shows an small difference between them which is the
        * used one to determine the direction.
        */
        function touchMoveHandler(event) {
            var e = event.originalEvent;
            // additional: if one of the normalScrollElements isn't within options.normalScrollElementTouchThreshold hops up the DOM chain
            if (!checkParentForNormalScrollElement(event.target) && isReallyTouch(e)) {
                if (options.autoScrolling) {
                    //preventing the easing on iOS devices
                    event.preventDefault();
                }
                var activeSection = $(SECTION_ACTIVE_SEL);
                var scrollable = isScrollable(activeSection);
                if (canScroll && !slideMoving) {
                    //if theres any #
                    var touchEvents = getEventsPage(e);
                    touchEndY = touchEvents.y;
                    touchEndX = touchEvents.x;
                    //if movement in the X axys is greater than in the Y and the currect section has slides...
                    if (activeSection.find(SLIDES_WRAPPER_SEL).length && Math.abs(touchStartX - touchEndX) > Math.abs(touchStartY - touchEndY)) {
                        //is the movement greater than the minimum resistance to scroll?
                        if (Math.abs(touchStartX - touchEndX) > $window.width() / 100 * options.touchSensitivity) {
                            if (touchStartX > touchEndX) {
                                if (isScrollAllowed.right) {
                                    FP.moveSlideRight();
                                }
                            } else {
                                if (isScrollAllowed.left) {
                                    FP.moveSlideLeft();
                                }
                            }
                        }
                    } else if (options.autoScrolling) {
                        //is the movement greater than the minimum resistance to scroll?
                        if (Math.abs(touchStartY - touchEndY) > $window.height() / 100 * options.touchSensitivity) {
                            if (touchStartY > touchEndY) {
                                scrolling("down", scrollable);
                            } else if (touchEndY > touchStartY) {
                                scrolling("up", scrollable);
                            }
                        }
                    }
                }
            }
        }
        /**
         * recursive function to loop up the parent nodes to check if one of them exists in options.normalScrollElements
         * Currently works well for iOS - Android might need some testing
         * @param  {Element} el  target element / jquery selector (in subsequent nodes)
         * @param  {int}     hop current hop compared to options.normalScrollElementTouchThreshold
         * @return {boolean} true if there is a match to options.normalScrollElements
         */
        function checkParentForNormalScrollElement(el, hop) {
            hop = hop || 0;
            var parent = $(el).parent();
            if (hop < options.normalScrollElementTouchThreshold && parent.is(options.normalScrollElements)) {
                return true;
            } else if (hop == options.normalScrollElementTouchThreshold) {
                return false;
            } else {
                return checkParentForNormalScrollElement(parent, ++hop);
            }
        }
        /**
        * As IE >= 10 fires both touch and mouse events when using a mouse in a touchscreen
        * this way we make sure that is really a touch event what IE is detecting.
        */
        function isReallyTouch(e) {
            //if is not IE   ||  IE is detecting `touch` or `pen`
            return typeof e.pointerType === "undefined" || e.pointerType != "mouse";
        }
        function touchStartHandler(event) {
            var e = event.originalEvent;
            //stopping the auto scroll to adjust to a section
            if (options.fitToSection) {
                $htmlBody.stop();
            }
            if (isReallyTouch(e)) {
                var touchEvents = getEventsPage(e);
                touchStartY = touchEvents.y;
                touchStartX = touchEvents.x;
            }
        }
        function getAverage(elements, number) {
            var sum = 0;
            //taking `number` elements from the end to make the average, if there are not enought, 1
            var lastElements = elements.slice(Math.max(elements.length - number, 1));
            for (var i = 0; i < lastElements.length; i++) {
                sum = sum + lastElements[i];
            }
            return Math.ceil(sum / number);
        }
        /**
         * Detecting mousewheel scrolling
         *
         * http://blogs.sitepointstatic.com/examples/tech/mouse-wheel/index.html
         * http://www.sitepoint.com/html5-javascript-mouse-wheel/
         */
        var prevTime = new Date().getTime();
        function MouseWheelHandler(e) {
            var curTime = new Date().getTime();
            if (options.autoScrolling) {
                // cross-browser wheel delta
                e = window.event || e;
                var value = e.wheelDelta || -e.deltaY || -e.detail;
                var delta = Math.max(-1, Math.min(1, value));
                //Limiting the array to 150 (lets not waist memory!)
                if (scrollings.length > 149) {
                    scrollings.shift();
                }
                //keeping record of the previous scrollings
                scrollings.push(Math.abs(value));
                //preventing to scroll the site on mouse wheel when scrollbar is present
                if (options.scrollBar) {
                    e.preventDefault ? e.preventDefault() : e.returnValue = false;
                }
                var activeSection = $(SECTION_ACTIVE_SEL);
                var scrollable = isScrollable(activeSection);
                //time difference between the last scroll and the current one
                var timeDiff = curTime - prevTime;
                prevTime = curTime;
                //haven't they scrolled in a while?
                //(enough to be consider a different scrolling action to scroll another section)
                if (timeDiff > 200) {
                    //emptying the array, we dont care about old scrollings for our averages
                    scrollings = [];
                }
                if (canScroll) {
                    var averageEnd = getAverage(scrollings, 10);
                    var averageMiddle = getAverage(scrollings, 70);
                    var isAccelerating = averageEnd >= averageMiddle;
                    //to avoid double swipes...
                    if (isAccelerating) {
                        //scrolling down?
                        if (delta < 0) {
                            scrolling("down", scrollable);
                        } else {
                            scrolling("up", scrollable);
                        }
                    }
                }
                return false;
            }
            if (options.fitToSection) {
                //stopping the auto scroll to adjust to a section
                $htmlBody.stop();
            }
        }
        function moveSlide(direction) {
            var activeSection = $(SECTION_ACTIVE_SEL);
            var slides = activeSection.find(SLIDES_WRAPPER_SEL);
            // more than one slide needed and nothing should be sliding
            if (!slides.length || slideMoving) {
                return;
            }
            var currentSlide = slides.find(SLIDE_ACTIVE_SEL);
            var destiny = null;
            if (direction === "prev") {
                destiny = currentSlide.prev(SLIDE_SEL);
            } else {
                destiny = currentSlide.next(SLIDE_SEL);
            }
            //isn't there a next slide in the secuence?
            if (!destiny.length) {
                //respect loopHorizontal settin
                if (!options.loopHorizontal) return;
                if (direction === "prev") {
                    destiny = currentSlide.siblings(":last");
                } else {
                    destiny = currentSlide.siblings(":first");
                }
            }
            slideMoving = true;
            landscapeScroll(slides, destiny);
        }
        /**
        * Maintains the active slides in the viewport
        * (Because he `scroll` animation might get lost with some actions, such as when using continuousVertical)
        */
        function keepSlidesPosition() {
            $(SLIDE_ACTIVE_SEL).each(function() {
                silentLandscapeScroll($(this));
            });
        }
        /**
        * Scrolls the site to the given element and scrolls to the slide if a callback is given.
        */
        function scrollPage(element, callback, isMovementUp) {
            var dest = element.position();
            if (typeof dest === "undefined") {
                return;
            }
            //there's no element to scroll, leaving the function
            //local variables
            var v = {
                element: element,
                callback: callback,
                isMovementUp: isMovementUp,
                dest: dest,
                dtop: dest.top,
                yMovement: getYmovement(element),
                anchorLink: element.data("anchor"),
                sectionIndex: element.index(SECTION_SEL),
                activeSlide: element.find(SLIDE_ACTIVE_SEL),
                activeSection: $(SECTION_ACTIVE_SEL),
                leavingSection: $(SECTION_ACTIVE_SEL).index(SECTION_SEL) + 1,
                //caching the value of isResizing at the momment the function is called
                //because it will be checked later inside a setTimeout and the value might change
                localIsResizing: isResizing
            };
            //quiting when destination scroll is the same as the current one
            if (v.activeSection.is(element) && !isResizing || options.scrollBar && $window.scrollTop() === v.dtop) {
                return;
            }
            if (v.activeSlide.length) {
                var slideAnchorLink = v.activeSlide.data("anchor");
                var slideIndex = v.activeSlide.index();
            }
            // If continuousVertical && we need to wrap around
            if (options.autoScrolling && options.continuousVertical && typeof v.isMovementUp !== "undefined" && (!v.isMovementUp && v.yMovement == "up" || // Intending to scroll down but about to go up or
            v.isMovementUp && v.yMovement == "down")) {
                // intending to scroll up but about to go down
                v = createInfiniteSections(v);
            }
            element.addClass(ACTIVE).siblings().removeClass(ACTIVE);
            //preventing from activating the MouseWheelHandler event
            //more than once if the page is scrolling
            canScroll = false;
            setState(slideIndex, slideAnchorLink, v.anchorLink, v.sectionIndex);
            //callback (onLeave) if the site is not just resizing and readjusting the slides
            $.isFunction(options.onLeave) && !v.localIsResizing && options.onLeave.call(v.activeSection, v.leavingSection, v.sectionIndex + 1, v.yMovement);
            performMovement(v);
            //flag to avoid callingn `scrollPage()` twice in case of using anchor links
            lastScrolledDestiny = v.anchorLink;
            //avoid firing it twice (as it does also on scroll)
            activateMenuAndNav(v.anchorLink, v.sectionIndex);
        }
        /**
        * Performs the movement (by CSS3 or by jQuery)
        */
        function performMovement(v) {
            // using CSS3 translate functionality
            if (options.css3 && options.autoScrolling && !options.scrollBar) {
                var translate3d = "translate3d(0px, -" + v.dtop + "px, 0px)";
                transformContainer(translate3d, true);
                setTimeout(function() {
                    afterSectionLoads(v);
                }, options.scrollingSpeed);
            } else {
                var scrollSettings = getScrollSettings(v);
                $(scrollSettings.element).animate(scrollSettings.options, options.scrollingSpeed, options.easing).promise().done(function() {
                    //only one single callback in case of animating  `html, body`
                    afterSectionLoads(v);
                });
            }
        }
        /**
        * Gets the scrolling settings depending on the plugin autoScrolling option
        */
        function getScrollSettings(v) {
            var scroll = {};
            if (options.autoScrolling && !options.scrollBar) {
                scroll.options = {
                    top: -v.dtop
                };
                scroll.element = WRAPPER_SEL;
            } else {
                scroll.options = {
                    scrollTop: v.dtop
                };
                scroll.element = "html, body";
            }
            return scroll;
        }
        /**
        * Adds sections before or after the current one to create the infinite effect.
        */
        function createInfiniteSections(v) {
            // Scrolling down
            if (!v.isMovementUp) {
                // Move all previous sections to after the active section
                $(SECTION_ACTIVE_SEL).after(v.activeSection.prevAll(SECTION_SEL).get().reverse());
            } else {
                // Scrolling up
                // Move all next sections to before the active section
                $(SECTION_ACTIVE_SEL).before(v.activeSection.nextAll(SECTION_SEL));
            }
            // Maintain the displayed position (now that we changed the element order)
            silentScroll($(SECTION_ACTIVE_SEL).position().top);
            // Maintain the active slides visible in the viewport
            keepSlidesPosition();
            // save for later the elements that still need to be reordered
            v.wrapAroundElements = v.activeSection;
            // Recalculate animation variables
            v.dest = v.element.position();
            v.dtop = v.dest.top;
            v.yMovement = getYmovement(v.element);
            return v;
        }
        /**
        * Fix section order after continuousVertical changes have been animated
        */
        function continuousVerticalFixSectionOrder(v) {
            // If continuousVertical is in effect (and autoScrolling would also be in effect then),
            // finish moving the elements around so the direct navigation will function more simply
            if (!v.wrapAroundElements || !v.wrapAroundElements.length) {
                return;
            }
            if (v.isMovementUp) {
                $(SECTION_FIRST_SEL).before(v.wrapAroundElements);
            } else {
                $(SECTION_LAST_SEL).after(v.wrapAroundElements);
            }
            silentScroll($(SECTION_ACTIVE_SEL).position().top);
            // Maintain the active slides visible in the viewport
            keepSlidesPosition();
        }
        /**
        * Actions to do once the section is loaded
        */
        function afterSectionLoads(v) {
            continuousVerticalFixSectionOrder(v);
            //callback (afterLoad) if the site is not just resizing and readjusting the slides
            $.isFunction(options.afterLoad) && !v.localIsResizing && options.afterLoad.call(v.element, v.anchorLink, v.sectionIndex + 1);
            canScroll = true;
            setTimeout(function() {
                $.isFunction(v.callback) && v.callback.call(this);
            }, 600);
        }
        /**
        * Scrolls to the anchor in the URL when loading the site
        */
        function scrollToAnchor() {
            //getting the anchor link in the URL and deleting the `#`
            var value = window.location.hash.replace("#", "").split("/");
            var section = value[0];
            var slide = value[1];
            if (section) {
                //if theres any #
                scrollPageAndSlide(section, slide);
            }
        }
        //detecting any change on the URL to scroll to the given anchor link
        //(a way to detect back history button as we play with the hashes on the URL)
        $window.on("hashchange", hashChangeHandler);
        function hashChangeHandler() {
            if (!isScrolling) {
                var value = window.location.hash.replace("#", "").split("/");
                var section = value[0];
                var slide = value[1];
                if (section.length) {
                    //when moving to a slide in the first section for the first time (first time to add an anchor to the URL)
                    var isFirstSlideMove = typeof lastScrolledDestiny === "undefined";
                    var isFirstScrollMove = typeof lastScrolledDestiny === "undefined" && typeof slide === "undefined" && !slideMoving;
                    /*in order to call scrollpage() only once for each destination at a time
                    It is called twice for each scroll otherwise, as in case of using anchorlinks `hashChange`
                    event is fired on every scroll too.*/
                    if (section && section !== lastScrolledDestiny && !isFirstSlideMove || isFirstScrollMove || !slideMoving && lastScrolledSlide != slide) {
                        scrollPageAndSlide(section, slide);
                    }
                }
            }
        }
        /**
         * Sliding with arrow keys, both, vertical and horizontal
         */
        $document.keydown(keydownHandler);
        var keydownId;
        function keydownHandler(e) {
            clearTimeout(keydownId);
            var activeElement = $(document.activeElement);
            if (!activeElement.is("textarea") && !activeElement.is("input") && !activeElement.is("select") && options.keyboardScrolling && options.autoScrolling) {
                var keyCode = e.which;
                //preventing the scroll with arrow keys & spacebar & Page Up & Down keys
                var keyControls = [ 40, 38, 32, 33, 34 ];
                if ($.inArray(keyCode, keyControls) > -1) {
                    e.preventDefault();
                }
                keydownId = setTimeout(function() {
                    onkeydown(e);
                }, 150);
            }
        }
        function onkeydown(e) {
            var shiftPressed = e.shiftKey;
            switch (e.which) {
              //up
                case 38:
              case 33:
                FP.moveSectionUp();
                break;

              //down
                case 32:
                //spacebar
                if (shiftPressed) {
                    FP.moveSectionUp();
                    break;
                }

              case 40:
              case 34:
                FP.moveSectionDown();
                break;

              //Home
                case 36:
                FP.moveTo(1);
                break;

              //End
                case 35:
                FP.moveTo($(SECTION_SEL).length);
                break;

              //left
                case 37:
                FP.moveSlideLeft();
                break;

              //right
                case 39:
                FP.moveSlideRight();
                break;

              default:
                return;
            }
        }
        //binding the mousemove when the mouse's middle button is released
        container.mousedown(function(e) {
            //middle button
            if (e.which == 2) {
                oldPageY = e.pageY;
                container.on("mousemove", mouseMoveHandler);
            }
        });
        //unbinding the mousemove when the mouse's middle button is released
        container.mouseup(function(e) {
            //middle button
            if (e.which == 2) {
                container.off("mousemove");
            }
        });
        /**
        * Detecting the direction of the mouse movement.
        * Used only for the middle button of the mouse.
        */
        var oldPageY = 0;
        function mouseMoveHandler(e) {
            // moving up
            if (canScroll) {
                if (e.pageY < oldPageY) {
                    FP.moveSectionUp();
                } else if (e.pageY > oldPageY) {
                    FP.moveSectionDown();
                }
            }
            oldPageY = e.pageY;
        }
        /**
        * Scrolls to the section when clicking the navigation bullet
        */
        $document.on("click touchstart", SECTION_NAV_SEL + " a", function(e) {
            e.preventDefault();
            var index = $(this).parent().index();
            scrollPage($(SECTION_SEL).eq(index));
        });
        /**
        * Scrolls the slider to the given slide destination for the given section
        */
        $document.on("click touchstart", SLIDES_NAV_LINK_SEL, function(e) {
            e.preventDefault();
            var slides = $(this).closest(SECTION_SEL).find(SLIDES_WRAPPER_SEL);
            var destiny = slides.find(SLIDE_SEL).eq($(this).closest("li").index());
            landscapeScroll(slides, destiny);
        });
        if (options.normalScrollElements) {
            $document.on("mouseenter", options.normalScrollElements, function() {
                FP.setMouseWheelScrolling(false);
            });
            $document.on("mouseleave", options.normalScrollElements, function() {
                FP.setMouseWheelScrolling(true);
            });
        }
        /**
         * Scrolling horizontally when clicking on the slider controls.
         */
        $(SECTION_SEL).on("click touchstart", SLIDES_ARROW_SEL, function() {
            if ($(this).hasClass(SLIDES_PREV)) {
                FP.moveSlideLeft();
            } else {
                FP.moveSlideRight();
            }
        });
        /**
        * Scrolls horizontal sliders.
        */
        function landscapeScroll(slides, destiny) {
            var destinyPos = destiny.position();
            var slideIndex = destiny.index();
            var section = slides.closest(SECTION_SEL);
            var sectionIndex = section.index(SECTION_SEL);
            var anchorLink = section.data("anchor");
            var slidesNav = section.find(SLIDES_NAV_SEL);
            var slideAnchor = getSlideAnchor(destiny);
            //caching the value of isResizing at the momment the function is called
            //because it will be checked later inside a setTimeout and the value might change
            var localIsResizing = isResizing;
            if (options.onSlideLeave) {
                var prevSlide = section.find(SLIDE_ACTIVE_SEL);
                var prevSlideIndex = prevSlide.index();
                var xMovement = getXmovement(prevSlideIndex, slideIndex);
                //if the site is not just resizing and readjusting the slides
                if (!localIsResizing && xMovement !== "none") {
                    $.isFunction(options.onSlideLeave) && options.onSlideLeave.call(prevSlide, anchorLink, sectionIndex + 1, prevSlideIndex, xMovement);
                }
            }
            destiny.addClass(ACTIVE).siblings().removeClass(ACTIVE);
            if (!options.loopHorizontal && options.controlArrows) {
                //hidding it for the fist slide, showing for the rest
                section.find(SLIDES_ARROW_PREV_SEL).toggle(slideIndex !== 0);
                //hidding it for the last slide, showing for the rest
                section.find(SLIDES_ARROW_NEXT_SEL).toggle(!destiny.is(":last-child"));
            }
            //only changing the URL if the slides are in the current section (not for resize re-adjusting)
            if (section.hasClass(ACTIVE)) {
                setState(slideIndex, slideAnchor, anchorLink, sectionIndex);
            }
            var afterSlideLoads = function() {
                //if the site is not just resizing and readjusting the slides
                if (!localIsResizing) {
                    $.isFunction(options.afterSlideLoad) && options.afterSlideLoad.call(destiny, anchorLink, sectionIndex + 1, slideAnchor, slideIndex);
                }
                //letting them slide again
                slideMoving = false;
            };
            if (options.css3) {
                var translate3d = "translate3d(-" + destinyPos.left + "px, 0px, 0px)";
                addAnimation(slides.find(SLIDES_CONTAINER_SEL), options.scrollingSpeed > 0).css(getTransforms(translate3d));
                setTimeout(function() {
                    afterSlideLoads();
                }, options.scrollingSpeed, options.easing);
            } else {
                slides.animate({
                    scrollLeft: destinyPos.left
                }, options.scrollingSpeed, options.easing, function() {
                    afterSlideLoads();
                });
            }
            slidesNav.find(ACTIVE_SEL).removeClass(ACTIVE);
            slidesNav.find("li").eq(slideIndex).find("a").addClass(ACTIVE);
        }
        //when resizing the site, we adjust the heights of the sections, slimScroll...
        $window.resize(resizeHandler);
        var previousHeight = windowsHeight;
        var resizeId;
        function resizeHandler() {
            //checking if it needs to get responsive
            responsive();
            // rebuild immediately on touch devices
            if (isTouchDevice) {
                var activeElement = $(document.activeElement);
                //if the keyboard is NOT visible
                if (!activeElement.is("textarea") && !activeElement.is("input") && !activeElement.is("select")) {
                    var currentHeight = $window.height();
                    //making sure the change in the viewport size is enough to force a rebuild. (20 % of the window to avoid problems when hidding scroll bars)
                    if (Math.abs(currentHeight - previousHeight) > 20 * Math.max(previousHeight, currentHeight) / 100) {
                        FP.reBuild(true);
                        previousHeight = currentHeight;
                    }
                }
            } else {
                //in order to call the functions only when the resize is finished
                //http://stackoverflow.com/questions/4298612/jquery-how-to-call-resize-event-only-once-its-finished-resizing
                clearTimeout(resizeId);
                resizeId = setTimeout(function() {
                    FP.reBuild(true);
                }, 500);
            }
        }
        /**
        * Checks if the site needs to get responsive and disables autoScrolling if so.
        * A class `fp-responsive` is added to the plugin's container in case the user wants to use it for his own responsive CSS.
        */
        function responsive() {
            if (options.responsive) {
                var isResponsive = container.hasClass(RESPONSIVE);
                if ($window.width() < options.responsive) {
                    if (!isResponsive) {
                        FP.setAutoScrolling(false, "internal");
                        FP.setFitToSection(false, "internal");
                        $(SECTION_NAV_SEL).hide();
                        container.addClass(RESPONSIVE);
                    }
                } else if (isResponsive) {
                    FP.setAutoScrolling(originals.autoScrolling, "internal");
                    FP.setFitToSection(originals.autoScrolling, "internal");
                    $(SECTION_NAV_SEL).show();
                    container.removeClass(RESPONSIVE);
                }
            }
        }
        /**
        * Adds transition animations for the given element
        */
        function addAnimation(element) {
            var transition = "all " + options.scrollingSpeed + "ms " + options.easingcss3;
            element.removeClass(NO_TRANSITION);
            return element.css({
                "-webkit-transition": transition,
                transition: transition
            });
        }
        /**
        * Remove transition animations for the given element
        */
        function removeAnimation(element) {
            return element.addClass(NO_TRANSITION);
        }
        /**
         * Resizing of the font size depending on the window size as well as some of the images on the site.
         */
        function resizeMe(displayHeight, displayWidth) {
            //Standard dimensions, for which the body font size is correct
            var preferredHeight = 825;
            var preferredWidth = 900;
            if (displayHeight < preferredHeight || displayWidth < preferredWidth) {
                var heightPercentage = displayHeight * 100 / preferredHeight;
                var widthPercentage = displayWidth * 100 / preferredWidth;
                var percentage = Math.min(heightPercentage, widthPercentage);
                var newFontSize = percentage.toFixed(2);
                $body.css("font-size", newFontSize + "%");
            } else {
                $body.css("font-size", "100%");
            }
        }
        /**
         * Activating the website navigation dots according to the given slide name.
         */
        function activateNavDots(name, sectionIndex) {
            if (options.navigation) {
                $(SECTION_NAV_SEL).find(ACTIVE_SEL).removeClass(ACTIVE);
                if (name) {
                    $(SECTION_NAV_SEL).find('a[href="#' + name + '"]').addClass(ACTIVE);
                } else {
                    $(SECTION_NAV_SEL).find("li").eq(sectionIndex).find("a").addClass(ACTIVE);
                }
            }
        }
        /**
         * Activating the website main menu elements according to the given slide name.
         */
        function activateMenuElement(name) {
            if (options.menu) {
                $(options.menu).find(ACTIVE_SEL).removeClass(ACTIVE);
                $(options.menu).find('[data-menuanchor="' + name + '"]').addClass(ACTIVE);
            }
        }
        function activateMenuAndNav(anchor, index) {
            activateMenuElement(anchor);
            activateNavDots(anchor, index);
        }
        /**
        * Return a boolean depending on whether the scrollable element is at the end or at the start of the scrolling
        * depending on the given type.
        */
        function isScrolled(type, scrollable) {
            if (type === "top") {
                return !scrollable.scrollTop();
            } else if (type === "bottom") {
                return scrollable.scrollTop() + 1 + scrollable.innerHeight() >= scrollable[0].scrollHeight;
            }
        }
        /**
        * Retuns `up` or `down` depending on the scrolling movement to reach its destination
        * from the current section.
        */
        function getYmovement(destiny) {
            var fromIndex = $(SECTION_ACTIVE_SEL).index(SECTION_SEL);
            var toIndex = destiny.index(SECTION_SEL);
            if (fromIndex == toIndex) {
                return "none";
            }
            if (fromIndex > toIndex) {
                return "up";
            }
            return "down";
        }
        /**
        * Retuns `right` or `left` depending on the scrolling movement to reach its destination
        * from the current slide.
        */
        function getXmovement(fromIndex, toIndex) {
            if (fromIndex == toIndex) {
                return "none";
            }
            if (fromIndex > toIndex) {
                return "left";
            }
            return "right";
        }
        function createSlimScrolling(element) {
            //needed to make `scrollHeight` work under Opera 12
            element.css("overflow", "hidden");
            //in case element is a slide
            var section = element.closest(SECTION_SEL);
            var scrollable = element.find(SCROLLABLE_SEL);
            var contentHeight;
            //if there was scroll, the contentHeight will be the one in the scrollable section
            if (scrollable.length) {
                contentHeight = scrollable.get(0).scrollHeight;
            } else {
                contentHeight = element.get(0).scrollHeight;
                if (options.verticalCentered) {
                    contentHeight = element.find(TABLE_CELL_SEL).get(0).scrollHeight;
                }
            }
            var scrollHeight = windowsHeight - parseInt(section.css("padding-bottom")) - parseInt(section.css("padding-top"));
            //needs scroll?
            if (contentHeight > scrollHeight) {
                //was there already an scroll ? Updating it
                if (scrollable.length) {
                    scrollable.css("height", scrollHeight + "px").parent().css("height", scrollHeight + "px");
                } else {
                    if (options.verticalCentered) {
                        element.find(TABLE_CELL_SEL).wrapInner('<div class="' + SCROLLABLE + '" />');
                    } else {
                        element.wrapInner('<div class="' + SCROLLABLE + '" />');
                    }
                    element.find(SCROLLABLE_SEL).slimScroll({
                        allowPageScroll: true,
                        height: scrollHeight + "px",
                        size: "10px",
                        alwaysVisible: true
                    });
                }
            } else {
                removeSlimScroll(element);
            }
            //undo
            element.css("overflow", "");
        }
        function removeSlimScroll(element) {
            element.find(SCROLLABLE_SEL).children().first().unwrap().unwrap();
            element.find(SLIMSCROLL_BAR_SEL).remove();
            element.find(SLIMSCROLL_RAIL_SEL).remove();
        }
        function addTableClass(element) {
            element.addClass(TABLE).wrapInner('<div class="' + TABLE_CELL + '" style="height:' + getTableHeight(element) + 'px;" />');
        }
        function getTableHeight(element) {
            var sectionHeight = windowsHeight;
            if (options.paddingTop || options.paddingBottom) {
                var section = element;
                if (!section.hasClass(SECTION)) {
                    section = element.closest(SECTION_SEL);
                }
                var paddings = parseInt(section.css("padding-top")) + parseInt(section.css("padding-bottom"));
                sectionHeight = windowsHeight - paddings;
            }
            return sectionHeight;
        }
        /**
        * Adds a css3 transform property to the container class with or without animation depending on the animated param.
        */
        function transformContainer(translate3d, animated) {
            if (animated) {
                addAnimation(container);
            } else {
                removeAnimation(container);
            }
            container.css(getTransforms(translate3d));
            //syncronously removing the class after the animation has been applied.
            setTimeout(function() {
                container.removeClass(NO_TRANSITION);
            }, 10);
        }
        /**
        * Scrolls to the given section and slide
        */
        function scrollPageAndSlide(destiny, slide) {
            var section;
            if (typeof slide === "undefined") {
                slide = 0;
            }
            if (isNaN(destiny)) {
                section = $('[data-anchor="' + destiny + '"]');
            } else {
                section = $(SECTION_SEL).eq(destiny - 1);
            }
            //we need to scroll to the section and then to the slide
            if (destiny !== lastScrolledDestiny && !section.hasClass(ACTIVE)) {
                scrollPage(section, function() {
                    scrollSlider(section, slide);
                });
            } else {
                scrollSlider(section, slide);
            }
        }
        /**
        * Scrolls the slider to the given slide destination for the given section
        */
        function scrollSlider(section, slide) {
            if (typeof slide != "undefined") {
                var slides = section.find(SLIDES_WRAPPER_SEL);
                var destiny = slides.find('[data-anchor="' + slide + '"]');
                if (!destiny.length) {
                    destiny = slides.find(SLIDE_SEL).eq(slide);
                }
                if (destiny.length) {
                    landscapeScroll(slides, destiny);
                }
            }
        }
        /**
        * Creates a landscape navigation bar with dots for horizontal sliders.
        */
        function addSlidesNavigation(section, numSlides) {
            section.append('<div class="' + SLIDES_NAV + '"><ul></ul></div>');
            var nav = section.find(SLIDES_NAV_SEL);
            //top or bottom
            nav.addClass(options.slidesNavPosition);
            for (var i = 0; i < numSlides; i++) {
                nav.find("ul").append('<li><a href="#"><span></span></a></li>');
            }
            //centering it
            nav.css("margin-left", "-" + nav.width() / 2 + "px");
            nav.find("li").first().find("a").addClass(ACTIVE);
        }
        /**
        * Sets the state of the website depending on the active section/slide.
        * It changes the URL hash when needed and updates the body class.
        */
        function setState(slideIndex, slideAnchor, anchorLink, sectionIndex) {
            var sectionHash = "";
            if (options.anchors.length) {
                //isn't it the first slide?
                if (slideIndex) {
                    if (typeof anchorLink !== "undefined") {
                        sectionHash = anchorLink;
                    }
                    //slide without anchor link? We take the index instead.
                    if (typeof slideAnchor === "undefined") {
                        slideAnchor = slideIndex;
                    }
                    lastScrolledSlide = slideAnchor;
                    setUrlHash(sectionHash + "/" + slideAnchor);
                } else if (typeof slideIndex !== "undefined") {
                    lastScrolledSlide = slideAnchor;
                    setUrlHash(anchorLink);
                } else {
                    setUrlHash(anchorLink);
                }
            }
            setBodyClass();
        }
        /**
        * Sets the URL hash.
        */
        function setUrlHash(url) {
            if (options.recordHistory) {
                location.hash = url;
            } else {
                //Mobile Chrome doesn't work the normal way, so... lets use HTML5 for phones :)
                if (isTouchDevice || isTouch) {
                    history.replaceState(undefined, undefined, "#" + url);
                } else {
                    var baseUrl = window.location.href.split("#")[0];
                    window.location.replace(baseUrl + "#" + url);
                }
            }
        }
        /**
        * Gets the anchor for the given slide. Its index will be used if there's none.
        */
        function getSlideAnchor(slide) {
            var slideAnchor = slide.data("anchor");
            var slideIndex = slide.index();
            //Slide without anchor link? We take the index instead.
            if (typeof slideAnchor === "undefined") {
                slideAnchor = slideIndex;
            }
            return slideAnchor;
        }
        /**
        * Sets a class for the body of the page depending on the active section / slide
        */
        function setBodyClass() {
            var section = $(SECTION_ACTIVE_SEL);
            var slide = section.find(SLIDE_ACTIVE_SEL);
            var sectionAnchor = section.data("anchor");
            var slideAnchor = getSlideAnchor(slide);
            var sectionIndex = section.index(SECTION_SEL);
            var text = String(sectionIndex);
            if (options.anchors.length) {
                text = sectionAnchor;
            }
            if (slide.length) {
                text = text + "-" + slideAnchor;
            }
            //changing slash for dash to make it a valid CSS style
            text = text.replace("/", "-").replace("#", "");
            //removing previous anchor classes
            var classRe = new RegExp("\\b\\s?" + VIEWING_PREFIX + "-[^\\s]+\\b", "g");
            $body[0].className = $body[0].className.replace(classRe, "");
            //adding the current anchor
            $body.addClass(VIEWING_PREFIX + "-" + text);
        }
        /**
        * Checks for translate3d support
        * @return boolean
        * http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support
        */
        function support3d() {
            var el = document.createElement("p"), has3d, transforms = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            // Add it to the body to get the computed style.
            document.body.insertBefore(el, null);
            for (var t in transforms) {
                if (el.style[t] !== undefined) {
                    el.style[t] = "translate3d(1px,1px,1px)";
                    has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
                }
            }
            document.body.removeChild(el);
            return has3d !== undefined && has3d.length > 0 && has3d !== "none";
        }
        /**
        * Removes the auto scrolling action fired by the mouse wheel and trackpad.
        * After this function is called, the mousewheel and trackpad movements won't scroll through sections.
        */
        function removeMouseWheelHandler() {
            if (document.addEventListener) {
                document.removeEventListener("mousewheel", MouseWheelHandler, false);
                //IE9, Chrome, Safari, Oper
                document.removeEventListener("wheel", MouseWheelHandler, false);
            } else {
                document.detachEvent("onmousewheel", MouseWheelHandler);
            }
        }
        /**
        * Adds the auto scrolling action for the mouse wheel and trackpad.
        * After this function is called, the mousewheel and trackpad movements will scroll through sections
        */
        function addMouseWheelHandler() {
            if (document.addEventListener) {
                document.addEventListener("mousewheel", MouseWheelHandler, false);
                //IE9, Chrome, Safari, Oper
                document.addEventListener("wheel", MouseWheelHandler, false);
            } else {
                document.attachEvent("onmousewheel", MouseWheelHandler);
            }
        }
        /**
        * Adds the possibility to auto scroll through sections on touch devices.
        */
        function addTouchHandler() {
            if (isTouchDevice || isTouch) {
                //Microsoft pointers
                var MSPointer = getMSPointer();
                $(WRAPPER_SEL).off("touchstart " + MSPointer.down).on("touchstart " + MSPointer.down, touchStartHandler);
                $(WRAPPER_SEL).off("touchmove " + MSPointer.move).on("touchmove " + MSPointer.move, touchMoveHandler);
            }
        }
        /**
        * Removes the auto scrolling for touch devices.
        */
        function removeTouchHandler() {
            if (isTouchDevice || isTouch) {
                //Microsoft pointers
                var MSPointer = getMSPointer();
                $(WRAPPER_SEL).off("touchstart " + MSPointer.down);
                $(WRAPPER_SEL).off("touchmove " + MSPointer.move);
            }
        }
        /*
        * Returns and object with Microsoft pointers (for IE<11 and for IE >= 11)
        * http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx
        */
        function getMSPointer() {
            var pointer;
            //IE >= 11 & rest of browsers
            if (window.PointerEvent) {
                pointer = {
                    down: "pointerdown",
                    move: "pointermove"
                };
            } else {
                pointer = {
                    down: "MSPointerDown",
                    move: "MSPointerMove"
                };
            }
            return pointer;
        }
        /**
        * Gets the pageX and pageY properties depending on the browser.
        * https://github.com/alvarotrigo/fullPage.js/issues/194#issuecomment-34069854
        */
        function getEventsPage(e) {
            var events = [];
            events.y = typeof e.pageY !== "undefined" && (e.pageY || e.pageX) ? e.pageY : e.touches[0].pageY;
            events.x = typeof e.pageX !== "undefined" && (e.pageY || e.pageX) ? e.pageX : e.touches[0].pageX;
            //in touch devices with scrollBar:true, e.pageY is detected, but we have to deal with touch events. #1008
            if (isTouch && isReallyTouch(e)) {
                events.y = e.touches[0].pageY;
                events.x = e.touches[0].pageX;
            }
            return events;
        }
        function silentLandscapeScroll(activeSlide) {
            FP.setScrollingSpeed(0, "internal");
            landscapeScroll(activeSlide.closest(SLIDES_WRAPPER_SEL), activeSlide);
            FP.setScrollingSpeed(originals.scrollingSpeed, "internal");
        }
        function silentScroll(top) {
            if (options.scrollBar) {
                container.scrollTop(top);
            } else if (options.css3) {
                var translate3d = "translate3d(0px, -" + top + "px, 0px)";
                transformContainer(translate3d, false);
            } else {
                container.css("top", -top);
            }
        }
        function getTransforms(translate3d) {
            return {
                "-webkit-transform": translate3d,
                "-moz-transform": translate3d,
                "-ms-transform": translate3d,
                transform: translate3d
            };
        }
        function setIsScrollable(value, direction) {
            switch (direction) {
              case "up":
                isScrollAllowed.up = value;
                break;

              case "down":
                isScrollAllowed.down = value;
                break;

              case "left":
                isScrollAllowed.left = value;
                break;

              case "right":
                isScrollAllowed.right = value;
                break;

              case "all":
                FP.setAllowScrolling(value);
            }
        }
        /*
        * Destroys fullpage.js plugin events and optinally its html markup and styles
        */
        FP.destroy = function(all) {
            FP.setAutoScrolling(false, "internal");
            FP.setAllowScrolling(false);
            FP.setKeyboardScrolling(false);
            container.addClass(DESTROYED);
            $window.off("scroll", scrollHandler).off("hashchange", hashChangeHandler).off("resize", resizeHandler);
            $document.off("click", SECTION_NAV_SEL + " a").off("mouseenter", SECTION_NAV_SEL + " li").off("mouseleave", SECTION_NAV_SEL + " li").off("click", SLIDES_NAV_LINK_SEL).off("mouseover", options.normalScrollElements).off("mouseout", options.normalScrollElements);
            $(SECTION_SEL).off("click", SLIDES_ARROW_SEL);
            //lets make a mess!
            if (all) {
                destroyStructure();
            }
        };
        /*
        * Removes inline styles added by fullpage.js
        */
        function destroyStructure() {
            //reseting the `top` or `translate` properties to 0
            silentScroll(0);
            $(SECTION_NAV_SEL + ", " + SLIDES_NAV_SEL + ", " + SLIDES_ARROW_SEL).remove();
            //removing inline styles
            $(SECTION_SEL).css({
                height: "",
                "background-color": "",
                padding: ""
            });
            $(SLIDE_SEL).css({
                width: ""
            });
            container.css({
                height: "",
                position: "",
                "-ms-touch-action": "",
                "touch-action": ""
            });
            //removing added classes
            $(SECTION_SEL + ", " + SLIDE_SEL).each(function() {
                removeSlimScroll($(this));
                $(this).removeClass(TABLE + " " + ACTIVE);
            });
            removeAnimation(container);
            //Unwrapping content
            container.find(TABLE_CELL_SEL + ", " + SLIDES_CONTAINER_SEL + ", " + SLIDES_WRAPPER_SEL).each(function() {
                //unwrap not being use in case there's no child element inside and its just text
                $(this).replaceWith(this.childNodes);
            });
            //scrolling the page to the top with no animation
            $htmlBody.scrollTop(0);
        }
        /*
        * Sets the state for a variable with multiple states (original, and temporal)
        * Some variables such as `autoScrolling` or `recordHistory` might change automatically its state when using `responsive` or `autoScrolling:false`.
        * This function is used to keep track of both states, the original and the temporal one.
        * If type is not 'internal', then we assume the user is globally changing the variable.
        */
        function setVariableState(variable, value, type) {
            options[variable] = value;
            if (type !== "internal") {
                originals[variable] = value;
            }
        }
        /**
        * Displays warnings
        */
        function displayWarnings() {
            // Disable mutually exclusive settings
            if (options.continuousVertical && (options.loopTop || options.loopBottom)) {
                options.continuousVertical = false;
                showError("warn", "Option `loopTop/loopBottom` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled");
            }
            if (options.continuousVertical && options.scrollBar) {
                options.continuousVertical = false;
                showError("warn", "Option `scrollBar` is mutually exclusive with `continuousVertical`; `continuousVertical` disabled");
            }
            //anchors can not have the same value as any element ID or NAME
            $.each(options.anchors, function(index, name) {
                if ($("#" + name).length || $('[name="' + name + '"]').length) {
                    showError("error", "data-anchor tags can not have the same value as any `id` element on the site (or `name` element for IE).");
                }
            });
        }
        function showError(type, text) {
            console && console[type] && console[type]("fullPage: " + text);
        }
    };
})(jQuery, window, document, Math);

/*!
 * Masonry PACKAGED v3.3.0
 * Cascading grid layout library
 * http://masonry.desandro.com
 * MIT License
 * by David DeSandro
 */
!function(a) {
    function b() {}
    function c(a) {
        function c(b) {
            b.prototype.option || (b.prototype.option = function(b) {
                a.isPlainObject(b) && (this.options = a.extend(!0, this.options, b));
            });
        }
        function e(b, c) {
            a.fn[b] = function(e) {
                if ("string" == typeof e) {
                    for (var g = d.call(arguments, 1), h = 0, i = this.length; i > h; h++) {
                        var j = this[h], k = a.data(j, b);
                        if (k) if (a.isFunction(k[e]) && "_" !== e.charAt(0)) {
                            var l = k[e].apply(k, g);
                            if (void 0 !== l) return l;
                        } else f("no such method '" + e + "' for " + b + " instance"); else f("cannot call methods on " + b + " prior to initialization; attempted to call '" + e + "'");
                    }
                    return this;
                }
                return this.each(function() {
                    var d = a.data(this, b);
                    d ? (d.option(e), d._init()) : (d = new c(this, e), a.data(this, b, d));
                });
            };
        }
        if (a) {
            var f = "undefined" == typeof console ? b : function(a) {
                console.error(a);
            };
            return a.bridget = function(a, b) {
                c(b), e(a, b);
            }, a.bridget;
        }
    }
    var d = Array.prototype.slice;
    "function" == typeof define && define.amd ? define("jquery-bridget/jquery.bridget", [ "jquery" ], c) : c("object" == typeof exports ? require("jquery") : a.jQuery);
}(window), function(a) {
    function b(b) {
        var c = a.event;
        return c.target = c.target || c.srcElement || b, c;
    }
    var c = document.documentElement, d = function() {};
    c.addEventListener ? d = function(a, b, c) {
        a.addEventListener(b, c, !1);
    } : c.attachEvent && (d = function(a, c, d) {
        a[c + d] = d.handleEvent ? function() {
            var c = b(a);
            d.handleEvent.call(d, c);
        } : function() {
            var c = b(a);
            d.call(a, c);
        }, a.attachEvent("on" + c, a[c + d]);
    });
    var e = function() {};
    c.removeEventListener ? e = function(a, b, c) {
        a.removeEventListener(b, c, !1);
    } : c.detachEvent && (e = function(a, b, c) {
        a.detachEvent("on" + b, a[b + c]);
        try {
            delete a[b + c];
        } catch (d) {
            a[b + c] = void 0;
        }
    });
    var f = {
        bind: d,
        unbind: e
    };
    "function" == typeof define && define.amd ? define("eventie/eventie", f) : "object" == typeof exports ? module.exports = f : a.eventie = f;
}(window), function() {
    function a() {}
    function b(a, b) {
        for (var c = a.length; c--; ) if (a[c].listener === b) return c;
        return -1;
    }
    function c(a) {
        return function() {
            return this[a].apply(this, arguments);
        };
    }
    var d = a.prototype, e = this, f = e.EventEmitter;
    d.getListeners = function(a) {
        var b, c, d = this._getEvents();
        if (a instanceof RegExp) {
            b = {};
            for (c in d) d.hasOwnProperty(c) && a.test(c) && (b[c] = d[c]);
        } else b = d[a] || (d[a] = []);
        return b;
    }, d.flattenListeners = function(a) {
        var b, c = [];
        for (b = 0; b < a.length; b += 1) c.push(a[b].listener);
        return c;
    }, d.getListenersAsObject = function(a) {
        var b, c = this.getListeners(a);
        return c instanceof Array && (b = {}, b[a] = c), b || c;
    }, d.addListener = function(a, c) {
        var d, e = this.getListenersAsObject(a), f = "object" == typeof c;
        for (d in e) e.hasOwnProperty(d) && -1 === b(e[d], c) && e[d].push(f ? c : {
            listener: c,
            once: !1
        });
        return this;
    }, d.on = c("addListener"), d.addOnceListener = function(a, b) {
        return this.addListener(a, {
            listener: b,
            once: !0
        });
    }, d.once = c("addOnceListener"), d.defineEvent = function(a) {
        return this.getListeners(a), this;
    }, d.defineEvents = function(a) {
        for (var b = 0; b < a.length; b += 1) this.defineEvent(a[b]);
        return this;
    }, d.removeListener = function(a, c) {
        var d, e, f = this.getListenersAsObject(a);
        for (e in f) f.hasOwnProperty(e) && (d = b(f[e], c), -1 !== d && f[e].splice(d, 1));
        return this;
    }, d.off = c("removeListener"), d.addListeners = function(a, b) {
        return this.manipulateListeners(!1, a, b);
    }, d.removeListeners = function(a, b) {
        return this.manipulateListeners(!0, a, b);
    }, d.manipulateListeners = function(a, b, c) {
        var d, e, f = a ? this.removeListener : this.addListener, g = a ? this.removeListeners : this.addListeners;
        if ("object" != typeof b || b instanceof RegExp) for (d = c.length; d--; ) f.call(this, b, c[d]); else for (d in b) b.hasOwnProperty(d) && (e = b[d]) && ("function" == typeof e ? f.call(this, d, e) : g.call(this, d, e));
        return this;
    }, d.removeEvent = function(a) {
        var b, c = typeof a, d = this._getEvents();
        if ("string" === c) delete d[a]; else if (a instanceof RegExp) for (b in d) d.hasOwnProperty(b) && a.test(b) && delete d[b]; else delete this._events;
        return this;
    }, d.removeAllListeners = c("removeEvent"), d.emitEvent = function(a, b) {
        var c, d, e, f, g = this.getListenersAsObject(a);
        for (e in g) if (g.hasOwnProperty(e)) for (d = g[e].length; d--; ) c = g[e][d], 
        c.once === !0 && this.removeListener(a, c.listener), f = c.listener.apply(this, b || []), 
        f === this._getOnceReturnValue() && this.removeListener(a, c.listener);
        return this;
    }, d.trigger = c("emitEvent"), d.emit = function(a) {
        var b = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(a, b);
    }, d.setOnceReturnValue = function(a) {
        return this._onceReturnValue = a, this;
    }, d._getOnceReturnValue = function() {
        return this.hasOwnProperty("_onceReturnValue") ? this._onceReturnValue : !0;
    }, d._getEvents = function() {
        return this._events || (this._events = {});
    }, a.noConflict = function() {
        return e.EventEmitter = f, a;
    }, "function" == typeof define && define.amd ? define("eventEmitter/EventEmitter", [], function() {
        return a;
    }) : "object" == typeof module && module.exports ? module.exports = a : e.EventEmitter = a;
}.call(this), function(a) {
    function b(a) {
        if (a) {
            if ("string" == typeof d[a]) return a;
            a = a.charAt(0).toUpperCase() + a.slice(1);
            for (var b, e = 0, f = c.length; f > e; e++) if (b = c[e] + a, "string" == typeof d[b]) return b;
        }
    }
    var c = "Webkit Moz ms Ms O".split(" "), d = document.documentElement.style;
    "function" == typeof define && define.amd ? define("get-style-property/get-style-property", [], function() {
        return b;
    }) : "object" == typeof exports ? module.exports = b : a.getStyleProperty = b;
}(window), function(a) {
    function b(a) {
        var b = parseFloat(a), c = -1 === a.indexOf("%") && !isNaN(b);
        return c && b;
    }
    function c() {}
    function d() {
        for (var a = {
            width: 0,
            height: 0,
            innerWidth: 0,
            innerHeight: 0,
            outerWidth: 0,
            outerHeight: 0
        }, b = 0, c = g.length; c > b; b++) {
            var d = g[b];
            a[d] = 0;
        }
        return a;
    }
    function e(c) {
        function e() {
            if (!m) {
                m = !0;
                var d = a.getComputedStyle;
                if (j = function() {
                    var a = d ? function(a) {
                        return d(a, null);
                    } : function(a) {
                        return a.currentStyle;
                    };
                    return function(b) {
                        var c = a(b);
                        return c || f("Style returned " + c + ". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"), 
                        c;
                    };
                }(), k = c("boxSizing")) {
                    var e = document.createElement("div");
                    e.style.width = "200px", e.style.padding = "1px 2px 3px 4px", e.style.borderStyle = "solid", 
                    e.style.borderWidth = "1px 2px 3px 4px", e.style[k] = "border-box";
                    var g = document.body || document.documentElement;
                    g.appendChild(e);
                    var h = j(e);
                    l = 200 === b(h.width), g.removeChild(e);
                }
            }
        }
        function h(a) {
            if (e(), "string" == typeof a && (a = document.querySelector(a)), a && "object" == typeof a && a.nodeType) {
                var c = j(a);
                if ("none" === c.display) return d();
                var f = {};
                f.width = a.offsetWidth, f.height = a.offsetHeight;
                for (var h = f.isBorderBox = !(!k || !c[k] || "border-box" !== c[k]), m = 0, n = g.length; n > m; m++) {
                    var o = g[m], p = c[o];
                    p = i(a, p);
                    var q = parseFloat(p);
                    f[o] = isNaN(q) ? 0 : q;
                }
                var r = f.paddingLeft + f.paddingRight, s = f.paddingTop + f.paddingBottom, t = f.marginLeft + f.marginRight, u = f.marginTop + f.marginBottom, v = f.borderLeftWidth + f.borderRightWidth, w = f.borderTopWidth + f.borderBottomWidth, x = h && l, y = b(c.width);
                y !== !1 && (f.width = y + (x ? 0 : r + v));
                var z = b(c.height);
                return z !== !1 && (f.height = z + (x ? 0 : s + w)), f.innerWidth = f.width - (r + v), 
                f.innerHeight = f.height - (s + w), f.outerWidth = f.width + t, f.outerHeight = f.height + u, 
                f;
            }
        }
        function i(b, c) {
            if (a.getComputedStyle || -1 === c.indexOf("%")) return c;
            var d = b.style, e = d.left, f = b.runtimeStyle, g = f && f.left;
            return g && (f.left = b.currentStyle.left), d.left = c, c = d.pixelLeft, d.left = e, 
            g && (f.left = g), c;
        }
        var j, k, l, m = !1;
        return h;
    }
    var f = "undefined" == typeof console ? c : function(a) {
        console.error(a);
    }, g = [ "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth" ];
    "function" == typeof define && define.amd ? define("get-size/get-size", [ "../../../bower_components/get-style-property/get-style-property" ], e) : "object" == typeof exports ? module.exports = e(require("desandro-get-style-property")) : a.getSize = e(a.getStyleProperty);
}(window), function(a) {
    function b(a) {
        "function" == typeof a && (b.isReady ? a() : g.push(a));
    }
    function c(a) {
        var c = "readystatechange" === a.type && "complete" !== f.readyState;
        b.isReady || c || d();
    }
    function d() {
        b.isReady = !0;
        for (var a = 0, c = g.length; c > a; a++) {
            var d = g[a];
            d();
        }
    }
    function e(e) {
        return "complete" === f.readyState ? d() : (e.bind(f, "DOMContentLoaded", c), e.bind(f, "readystatechange", c), 
        e.bind(a, "load", c)), b;
    }
    var f = a.document, g = [];
    b.isReady = !1, "function" == typeof define && define.amd ? define("doc-ready/doc-ready", [ "../../../bower_components/eventie/eventie" ], e) : "object" == typeof exports ? module.exports = e(require("eventie")) : a.docReady = e(a.eventie);
}(window), function(a) {
    function b(a, b) {
        return a[g](b);
    }
    function c(a) {
        if (!a.parentNode) {
            var b = document.createDocumentFragment();
            b.appendChild(a);
        }
    }
    function d(a, b) {
        c(a);
        for (var d = a.parentNode.querySelectorAll(b), e = 0, f = d.length; f > e; e++) if (d[e] === a) return !0;
        return !1;
    }
    function e(a, d) {
        return c(a), b(a, d);
    }
    var f, g = function() {
        if (a.matches) return "matches";
        if (a.matchesSelector) return "matchesSelector";
        for (var b = [ "webkit", "moz", "ms", "o" ], c = 0, d = b.length; d > c; c++) {
            var e = b[c], f = e + "MatchesSelector";
            if (a[f]) return f;
        }
    }();
    if (g) {
        var h = document.createElement("div"), i = b(h, "div");
        f = i ? b : e;
    } else f = d;
    "function" == typeof define && define.amd ? define("matches-selector/matches-selector", [], function() {
        return f;
    }) : "object" == typeof exports ? module.exports = f : window.matchesSelector = f;
}(Element.prototype), function(a, b) {
    "function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", [ "doc-ready/doc-ready", "matches-selector/matches-selector" ], function(c, d) {
        return b(a, c, d);
    }) : "object" == typeof exports ? module.exports = b(a, require("doc-ready"), require("desandro-matches-selector")) : a.fizzyUIUtils = b(a, a.docReady, a.matchesSelector);
}(window, function(a, b, c) {
    var d = {};
    d.extend = function(a, b) {
        for (var c in b) a[c] = b[c];
        return a;
    }, d.modulo = function(a, b) {
        return (a % b + b) % b;
    };
    var e = Object.prototype.toString;
    d.isArray = function(a) {
        return "[object Array]" == e.call(a);
    }, d.makeArray = function(a) {
        var b = [];
        if (d.isArray(a)) b = a; else if (a && "number" == typeof a.length) for (var c = 0, e = a.length; e > c; c++) b.push(a[c]); else b.push(a);
        return b;
    }, d.indexOf = Array.prototype.indexOf ? function(a, b) {
        return a.indexOf(b);
    } : function(a, b) {
        for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
        return -1;
    }, d.removeFrom = function(a, b) {
        var c = d.indexOf(a, b);
        -1 != c && a.splice(c, 1);
    }, d.isElement = "function" == typeof HTMLElement || "object" == typeof HTMLElement ? function(a) {
        return a instanceof HTMLElement;
    } : function(a) {
        return a && "object" == typeof a && 1 == a.nodeType && "string" == typeof a.nodeName;
    }, d.setText = function() {
        function a(a, c) {
            b = b || (void 0 !== document.documentElement.textContent ? "textContent" : "innerText"), 
            a[b] = c;
        }
        var b;
        return a;
    }(), d.getParent = function(a, b) {
        for (;a != document.body; ) if (a = a.parentNode, c(a, b)) return a;
    }, d.getQueryElement = function(a) {
        return "string" == typeof a ? document.querySelector(a) : a;
    }, d.handleEvent = function(a) {
        var b = "on" + a.type;
        this[b] && this[b](a);
    }, d.filterFindElements = function(a, b) {
        a = d.makeArray(a);
        for (var e = [], f = 0, g = a.length; g > f; f++) {
            var h = a[f];
            if (d.isElement(h)) if (b) {
                c(h, b) && e.push(h);
                for (var i = h.querySelectorAll(b), j = 0, k = i.length; k > j; j++) e.push(i[j]);
            } else e.push(h);
        }
        return e;
    }, d.debounceMethod = function(a, b, c) {
        var d = a.prototype[b], e = b + "Timeout";
        a.prototype[b] = function() {
            var a = this[e];
            a && clearTimeout(a);
            var b = arguments, f = this;
            this[e] = setTimeout(function() {
                d.apply(f, b), delete f[e];
            }, c || 100);
        };
    }, d.toDashed = function(a) {
        return a.replace(/(.)([A-Z])/g, function(a, b, c) {
            return b + "-" + c;
        }).toLowerCase();
    };
    var f = a.console;
    return d.htmlInit = function(c, e) {
        b(function() {
            for (var b = d.toDashed(e), g = document.querySelectorAll(".js-" + b), h = "data-" + b + "-options", i = 0, j = g.length; j > i; i++) {
                var k, l = g[i], m = l.getAttribute(h);
                try {
                    k = m && JSON.parse(m);
                } catch (n) {
                    f && f.error("Error parsing " + h + " on " + l.nodeName.toLowerCase() + (l.id ? "#" + l.id : "") + ": " + n);
                    continue;
                }
                var o = new c(l, k), p = a.jQuery;
                p && p.data(l, e, o);
            }
        });
    }, d;
}), function(a, b) {
    "function" == typeof define && define.amd ? define("outlayer/item", [ "eventEmitter/EventEmitter", "get-size/get-size", "../../../bower_components/get-style-property/get-style-property", "fizzy-ui-utils/utils" ], function(c, d, e, f) {
        return b(a, c, d, e, f);
    }) : "object" == typeof exports ? module.exports = b(a, require("wolfy87-eventemitter"), require("get-size"), require("desandro-get-style-property"), require("fizzy-ui-utils")) : (a.Outlayer = {}, 
    a.Outlayer.Item = b(a, a.EventEmitter, a.getSize, a.getStyleProperty, a.fizzyUIUtils));
}(window, function(a, b, c, d, e) {
    function f(a) {
        for (var b in a) return !1;
        return b = null, !0;
    }
    function g(a, b) {
        a && (this.element = a, this.layout = b, this.position = {
            x: 0,
            y: 0
        }, this._create());
    }
    var h = a.getComputedStyle, i = h ? function(a) {
        return h(a, null);
    } : function(a) {
        return a.currentStyle;
    }, j = d("transition"), k = d("transform"), l = j && k, m = !!d("perspective"), n = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "otransitionend",
        transition: "transitionend"
    }[j], o = [ "transform", "transition", "transitionDuration", "transitionProperty" ], p = function() {
        for (var a = {}, b = 0, c = o.length; c > b; b++) {
            var e = o[b], f = d(e);
            f && f !== e && (a[e] = f);
        }
        return a;
    }();
    e.extend(g.prototype, b.prototype), g.prototype._create = function() {
        this._transn = {
            ingProperties: {},
            clean: {},
            onEnd: {}
        }, this.css({
            position: "absolute"
        });
    }, g.prototype.handleEvent = function(a) {
        var b = "on" + a.type;
        this[b] && this[b](a);
    }, g.prototype.getSize = function() {
        this.size = c(this.element);
    }, g.prototype.css = function(a) {
        var b = this.element.style;
        for (var c in a) {
            var d = p[c] || c;
            b[d] = a[c];
        }
    }, g.prototype.getPosition = function() {
        var a = i(this.element), b = this.layout.options, c = b.isOriginLeft, d = b.isOriginTop, e = parseInt(a[c ? "left" : "right"], 10), f = parseInt(a[d ? "top" : "bottom"], 10);
        e = isNaN(e) ? 0 : e, f = isNaN(f) ? 0 : f;
        var g = this.layout.size;
        e -= c ? g.paddingLeft : g.paddingRight, f -= d ? g.paddingTop : g.paddingBottom, 
        this.position.x = e, this.position.y = f;
    }, g.prototype.layoutPosition = function() {
        var a = this.layout.size, b = this.layout.options, c = {}, d = b.isOriginLeft ? "paddingLeft" : "paddingRight", e = b.isOriginLeft ? "left" : "right", f = b.isOriginLeft ? "right" : "left", g = this.position.x + a[d];
        g = b.percentPosition && !b.isHorizontal ? g / a.width * 100 + "%" : g + "px", c[e] = g, 
        c[f] = "";
        var h = b.isOriginTop ? "paddingTop" : "paddingBottom", i = b.isOriginTop ? "top" : "bottom", j = b.isOriginTop ? "bottom" : "top", k = this.position.y + a[h];
        k = b.percentPosition && b.isHorizontal ? k / a.height * 100 + "%" : k + "px", c[i] = k, 
        c[j] = "", this.css(c), this.emitEvent("layout", [ this ]);
    };
    var q = m ? function(a, b) {
        return "translate3d(" + a + "px, " + b + "px, 0)";
    } : function(a, b) {
        return "translate(" + a + "px, " + b + "px)";
    };
    g.prototype._transitionTo = function(a, b) {
        this.getPosition();
        var c = this.position.x, d = this.position.y, e = parseInt(a, 10), f = parseInt(b, 10), g = e === this.position.x && f === this.position.y;
        if (this.setPosition(a, b), g && !this.isTransitioning) return void this.layoutPosition();
        var h = a - c, i = b - d, j = {}, k = this.layout.options;
        h = k.isOriginLeft ? h : -h, i = k.isOriginTop ? i : -i, j.transform = q(h, i), 
        this.transition({
            to: j,
            onTransitionEnd: {
                transform: this.layoutPosition
            },
            isCleaning: !0
        });
    }, g.prototype.goTo = function(a, b) {
        this.setPosition(a, b), this.layoutPosition();
    }, g.prototype.moveTo = l ? g.prototype._transitionTo : g.prototype.goTo, g.prototype.setPosition = function(a, b) {
        this.position.x = parseInt(a, 10), this.position.y = parseInt(b, 10);
    }, g.prototype._nonTransition = function(a) {
        this.css(a.to), a.isCleaning && this._removeStyles(a.to);
        for (var b in a.onTransitionEnd) a.onTransitionEnd[b].call(this);
    }, g.prototype._transition = function(a) {
        if (!parseFloat(this.layout.options.transitionDuration)) return void this._nonTransition(a);
        var b = this._transn;
        for (var c in a.onTransitionEnd) b.onEnd[c] = a.onTransitionEnd[c];
        for (c in a.to) b.ingProperties[c] = !0, a.isCleaning && (b.clean[c] = !0);
        if (a.from) {
            this.css(a.from);
            var d = this.element.offsetHeight;
            d = null;
        }
        this.enableTransition(a.to), this.css(a.to), this.isTransitioning = !0;
    };
    var r = k && e.toDashed(k) + ",opacity";
    g.prototype.enableTransition = function() {
        this.isTransitioning || (this.css({
            transitionProperty: r,
            transitionDuration: this.layout.options.transitionDuration
        }), this.element.addEventListener(n, this, !1));
    }, g.prototype.transition = g.prototype[j ? "_transition" : "_nonTransition"], g.prototype.onwebkitTransitionEnd = function(a) {
        this.ontransitionend(a);
    }, g.prototype.onotransitionend = function(a) {
        this.ontransitionend(a);
    };
    var s = {
        "-webkit-transform": "transform",
        "-moz-transform": "transform",
        "-o-transform": "transform"
    };
    g.prototype.ontransitionend = function(a) {
        if (a.target === this.element) {
            var b = this._transn, c = s[a.propertyName] || a.propertyName;
            if (delete b.ingProperties[c], f(b.ingProperties) && this.disableTransition(), c in b.clean && (this.element.style[a.propertyName] = "", 
            delete b.clean[c]), c in b.onEnd) {
                var d = b.onEnd[c];
                d.call(this), delete b.onEnd[c];
            }
            this.emitEvent("transitionEnd", [ this ]);
        }
    }, g.prototype.disableTransition = function() {
        this.removeTransitionStyles(), this.element.removeEventListener(n, this, !1), this.isTransitioning = !1;
    }, g.prototype._removeStyles = function(a) {
        var b = {};
        for (var c in a) b[c] = "";
        this.css(b);
    };
    var t = {
        transitionProperty: "",
        transitionDuration: ""
    };
    return g.prototype.removeTransitionStyles = function() {
        this.css(t);
    }, g.prototype.removeElem = function() {
        this.element.parentNode.removeChild(this.element), this.css({
            display: ""
        }), this.emitEvent("remove", [ this ]);
    }, g.prototype.remove = function() {
        if (!j || !parseFloat(this.layout.options.transitionDuration)) return void this.removeElem();
        var a = this;
        this.once("transitionEnd", function() {
            a.removeElem();
        }), this.hide();
    }, g.prototype.reveal = function() {
        delete this.isHidden, this.css({
            display: ""
        });
        var a = this.layout.options, b = {}, c = this.getHideRevealTransitionEndProperty("visibleStyle");
        b[c] = this.onRevealTransitionEnd, this.transition({
            from: a.hiddenStyle,
            to: a.visibleStyle,
            isCleaning: !0,
            onTransitionEnd: b
        });
    }, g.prototype.onRevealTransitionEnd = function() {
        this.isHidden || this.emitEvent("reveal");
    }, g.prototype.getHideRevealTransitionEndProperty = function(a) {
        var b = this.layout.options[a];
        if (b.opacity) return "opacity";
        for (var c in b) return c;
    }, g.prototype.hide = function() {
        this.isHidden = !0, this.css({
            display: ""
        });
        var a = this.layout.options, b = {}, c = this.getHideRevealTransitionEndProperty("hiddenStyle");
        b[c] = this.onHideTransitionEnd, this.transition({
            from: a.visibleStyle,
            to: a.hiddenStyle,
            isCleaning: !0,
            onTransitionEnd: b
        });
    }, g.prototype.onHideTransitionEnd = function() {
        this.isHidden && (this.css({
            display: "none"
        }), this.emitEvent("hide"));
    }, g.prototype.destroy = function() {
        this.css({
            position: "",
            left: "",
            right: "",
            top: "",
            bottom: "",
            transition: "",
            transform: ""
        });
    }, g;
}), function(a, b) {
    "function" == typeof define && define.amd ? define("outlayer/outlayer", [ "../../../bower_components/eventie/eventie", "eventEmitter/EventEmitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item" ], function(c, d, e, f, g) {
        return b(a, c, d, e, f, g);
    }) : "object" == typeof exports ? module.exports = b(a, require("eventie"), require("wolfy87-eventemitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : a.Outlayer = b(a, a.eventie, a.EventEmitter, a.getSize, a.fizzyUIUtils, a.Outlayer.Item);
}(window, function(a, b, c, d, e, f) {
    function g(a, b) {
        var c = e.getQueryElement(a);
        if (!c) return void (h && h.error("Bad element for " + this.constructor.namespace + ": " + (c || a)));
        this.element = c, i && (this.$element = i(this.element)), this.options = e.extend({}, this.constructor.defaults), 
        this.option(b);
        var d = ++k;
        this.element.outlayerGUID = d, l[d] = this, this._create(), this.options.isInitLayout && this.layout();
    }
    var h = a.console, i = a.jQuery, j = function() {}, k = 0, l = {};
    return g.namespace = "outlayer", g.Item = f, g.defaults = {
        containerStyle: {
            position: "relative"
        },
        isInitLayout: !0,
        isOriginLeft: !0,
        isOriginTop: !0,
        isResizeBound: !0,
        isResizingContainer: !0,
        transitionDuration: "0.4s",
        hiddenStyle: {
            opacity: 0,
            transform: "scale(0.001)"
        },
        visibleStyle: {
            opacity: 1,
            transform: "scale(1)"
        }
    }, e.extend(g.prototype, c.prototype), g.prototype.option = function(a) {
        e.extend(this.options, a);
    }, g.prototype._create = function() {
        this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), e.extend(this.element.style, this.options.containerStyle), 
        this.options.isResizeBound && this.bindResize();
    }, g.prototype.reloadItems = function() {
        this.items = this._itemize(this.element.children);
    }, g.prototype._itemize = function(a) {
        for (var b = this._filterFindItemElements(a), c = this.constructor.Item, d = [], e = 0, f = b.length; f > e; e++) {
            var g = b[e], h = new c(g, this);
            d.push(h);
        }
        return d;
    }, g.prototype._filterFindItemElements = function(a) {
        return e.filterFindElements(a, this.options.itemSelector);
    }, g.prototype.getItemElements = function() {
        for (var a = [], b = 0, c = this.items.length; c > b; b++) a.push(this.items[b].element);
        return a;
    }, g.prototype.layout = function() {
        this._resetLayout(), this._manageStamps();
        var a = void 0 !== this.options.isLayoutInstant ? this.options.isLayoutInstant : !this._isLayoutInited;
        this.layoutItems(this.items, a), this._isLayoutInited = !0;
    }, g.prototype._init = g.prototype.layout, g.prototype._resetLayout = function() {
        this.getSize();
    }, g.prototype.getSize = function() {
        this.size = d(this.element);
    }, g.prototype._getMeasurement = function(a, b) {
        var c, f = this.options[a];
        f ? ("string" == typeof f ? c = this.element.querySelector(f) : e.isElement(f) && (c = f), 
        this[a] = c ? d(c)[b] : f) : this[a] = 0;
    }, g.prototype.layoutItems = function(a, b) {
        a = this._getItemsForLayout(a), this._layoutItems(a, b), this._postLayout();
    }, g.prototype._getItemsForLayout = function(a) {
        for (var b = [], c = 0, d = a.length; d > c; c++) {
            var e = a[c];
            e.isIgnored || b.push(e);
        }
        return b;
    }, g.prototype._layoutItems = function(a, b) {
        if (this._emitCompleteOnItems("layout", a), a && a.length) {
            for (var c = [], d = 0, e = a.length; e > d; d++) {
                var f = a[d], g = this._getItemLayoutPosition(f);
                g.item = f, g.isInstant = b || f.isLayoutInstant, c.push(g);
            }
            this._processLayoutQueue(c);
        }
    }, g.prototype._getItemLayoutPosition = function() {
        return {
            x: 0,
            y: 0
        };
    }, g.prototype._processLayoutQueue = function(a) {
        for (var b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            this._positionItem(d.item, d.x, d.y, d.isInstant);
        }
    }, g.prototype._positionItem = function(a, b, c, d) {
        d ? a.goTo(b, c) : a.moveTo(b, c);
    }, g.prototype._postLayout = function() {
        this.resizeContainer();
    }, g.prototype.resizeContainer = function() {
        if (this.options.isResizingContainer) {
            var a = this._getContainerSize();
            a && (this._setContainerMeasure(a.width, !0), this._setContainerMeasure(a.height, !1));
        }
    }, g.prototype._getContainerSize = j, g.prototype._setContainerMeasure = function(a, b) {
        if (void 0 !== a) {
            var c = this.size;
            c.isBorderBox && (a += b ? c.paddingLeft + c.paddingRight + c.borderLeftWidth + c.borderRightWidth : c.paddingBottom + c.paddingTop + c.borderTopWidth + c.borderBottomWidth), 
            a = Math.max(a, 0), this.element.style[b ? "width" : "height"] = a + "px";
        }
    }, g.prototype._emitCompleteOnItems = function(a, b) {
        function c() {
            e.emitEvent(a + "Complete", [ b ]);
        }
        function d() {
            g++, g === f && c();
        }
        var e = this, f = b.length;
        if (!b || !f) return void c();
        for (var g = 0, h = 0, i = b.length; i > h; h++) {
            var j = b[h];
            j.once(a, d);
        }
    }, g.prototype.ignore = function(a) {
        var b = this.getItem(a);
        b && (b.isIgnored = !0);
    }, g.prototype.unignore = function(a) {
        var b = this.getItem(a);
        b && delete b.isIgnored;
    }, g.prototype.stamp = function(a) {
        if (a = this._find(a)) {
            this.stamps = this.stamps.concat(a);
            for (var b = 0, c = a.length; c > b; b++) {
                var d = a[b];
                this.ignore(d);
            }
        }
    }, g.prototype.unstamp = function(a) {
        if (a = this._find(a)) for (var b = 0, c = a.length; c > b; b++) {
            var d = a[b];
            e.removeFrom(this.stamps, d), this.unignore(d);
        }
    }, g.prototype._find = function(a) {
        return a ? ("string" == typeof a && (a = this.element.querySelectorAll(a)), a = e.makeArray(a)) : void 0;
    }, g.prototype._manageStamps = function() {
        if (this.stamps && this.stamps.length) {
            this._getBoundingRect();
            for (var a = 0, b = this.stamps.length; b > a; a++) {
                var c = this.stamps[a];
                this._manageStamp(c);
            }
        }
    }, g.prototype._getBoundingRect = function() {
        var a = this.element.getBoundingClientRect(), b = this.size;
        this._boundingRect = {
            left: a.left + b.paddingLeft + b.borderLeftWidth,
            top: a.top + b.paddingTop + b.borderTopWidth,
            right: a.right - (b.paddingRight + b.borderRightWidth),
            bottom: a.bottom - (b.paddingBottom + b.borderBottomWidth)
        };
    }, g.prototype._manageStamp = j, g.prototype._getElementOffset = function(a) {
        var b = a.getBoundingClientRect(), c = this._boundingRect, e = d(a), f = {
            left: b.left - c.left - e.marginLeft,
            top: b.top - c.top - e.marginTop,
            right: c.right - b.right - e.marginRight,
            bottom: c.bottom - b.bottom - e.marginBottom
        };
        return f;
    }, g.prototype.handleEvent = function(a) {
        var b = "on" + a.type;
        this[b] && this[b](a);
    }, g.prototype.bindResize = function() {
        this.isResizeBound || (b.bind(a, "resize", this), this.isResizeBound = !0);
    }, g.prototype.unbindResize = function() {
        this.isResizeBound && b.unbind(a, "resize", this), this.isResizeBound = !1;
    }, g.prototype.onresize = function() {
        function a() {
            b.resize(), delete b.resizeTimeout;
        }
        this.resizeTimeout && clearTimeout(this.resizeTimeout);
        var b = this;
        this.resizeTimeout = setTimeout(a, 100);
    }, g.prototype.resize = function() {
        this.isResizeBound && this.needsResizeLayout() && this.layout();
    }, g.prototype.needsResizeLayout = function() {
        var a = d(this.element), b = this.size && a;
        return b && a.innerWidth !== this.size.innerWidth;
    }, g.prototype.addItems = function(a) {
        var b = this._itemize(a);
        return b.length && (this.items = this.items.concat(b)), b;
    }, g.prototype.appended = function(a) {
        var b = this.addItems(a);
        b.length && (this.layoutItems(b, !0), this.reveal(b));
    }, g.prototype.prepended = function(a) {
        var b = this._itemize(a);
        if (b.length) {
            var c = this.items.slice(0);
            this.items = b.concat(c), this._resetLayout(), this._manageStamps(), this.layoutItems(b, !0), 
            this.reveal(b), this.layoutItems(c);
        }
    }, g.prototype.reveal = function(a) {
        this._emitCompleteOnItems("reveal", a);
        for (var b = a && a.length, c = 0; b && b > c; c++) {
            var d = a[c];
            d.reveal();
        }
    }, g.prototype.hide = function(a) {
        this._emitCompleteOnItems("hide", a);
        for (var b = a && a.length, c = 0; b && b > c; c++) {
            var d = a[c];
            d.hide();
        }
    }, g.prototype.revealItemElements = function(a) {
        var b = this.getItems(a);
        this.reveal(b);
    }, g.prototype.hideItemElements = function(a) {
        var b = this.getItems(a);
        this.hide(b);
    }, g.prototype.getItem = function(a) {
        for (var b = 0, c = this.items.length; c > b; b++) {
            var d = this.items[b];
            if (d.element === a) return d;
        }
    }, g.prototype.getItems = function(a) {
        a = e.makeArray(a);
        for (var b = [], c = 0, d = a.length; d > c; c++) {
            var f = a[c], g = this.getItem(f);
            g && b.push(g);
        }
        return b;
    }, g.prototype.remove = function(a) {
        var b = this.getItems(a);
        if (this._emitCompleteOnItems("remove", b), b && b.length) for (var c = 0, d = b.length; d > c; c++) {
            var f = b[c];
            f.remove(), e.removeFrom(this.items, f);
        }
    }, g.prototype.destroy = function() {
        var a = this.element.style;
        a.height = "", a.position = "", a.width = "";
        for (var b = 0, c = this.items.length; c > b; b++) {
            var d = this.items[b];
            d.destroy();
        }
        this.unbindResize();
        var e = this.element.outlayerGUID;
        delete l[e], delete this.element.outlayerGUID, i && i.removeData(this.element, this.constructor.namespace);
    }, g.data = function(a) {
        a = e.getQueryElement(a);
        var b = a && a.outlayerGUID;
        return b && l[b];
    }, g.create = function(a, b) {
        function c() {
            g.apply(this, arguments);
        }
        return Object.create ? c.prototype = Object.create(g.prototype) : e.extend(c.prototype, g.prototype), 
        c.prototype.constructor = c, c.defaults = e.extend({}, g.defaults), e.extend(c.defaults, b), 
        c.prototype.settings = {}, c.namespace = a, c.data = g.data, c.Item = function() {
            f.apply(this, arguments);
        }, c.Item.prototype = new f(), e.htmlInit(c, a), i && i.bridget && i.bridget(a, c), 
        c;
    }, g.Item = f, g;
}), function(a, b) {
    "function" == typeof define && define.amd ? define([ "outlayer/outlayer", "get-size/get-size", "fizzy-ui-utils/utils" ], b) : "object" == typeof exports ? module.exports = b(require("outlayer"), require("get-size"), require("fizzy-ui-utils")) : a.Masonry = b(a.Outlayer, a.getSize, a.fizzyUIUtils);
}(window, function(a, b, c) {
    var d = a.create("masonry");
    return d.prototype._resetLayout = function() {
        this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), 
        this.measureColumns();
        var a = this.cols;
        for (this.colYs = []; a--; ) this.colYs.push(0);
        this.maxY = 0;
    }, d.prototype.measureColumns = function() {
        if (this.getContainerWidth(), !this.columnWidth) {
            var a = this.items[0], c = a && a.element;
            this.columnWidth = c && b(c).outerWidth || this.containerWidth;
        }
        var d = this.columnWidth += this.gutter, e = this.containerWidth + this.gutter, f = e / d, g = d - e % d, h = g && 1 > g ? "round" : "floor";
        f = Math[h](f), this.cols = Math.max(f, 1);
    }, d.prototype.getContainerWidth = function() {
        var a = this.options.isFitWidth ? this.element.parentNode : this.element, c = b(a);
        this.containerWidth = c && c.innerWidth;
    }, d.prototype._getItemLayoutPosition = function(a) {
        a.getSize();
        var b = a.size.outerWidth % this.columnWidth, d = b && 1 > b ? "round" : "ceil", e = Math[d](a.size.outerWidth / this.columnWidth);
        e = Math.min(e, this.cols);
        for (var f = this._getColGroup(e), g = Math.min.apply(Math, f), h = c.indexOf(f, g), i = {
            x: this.columnWidth * h,
            y: g
        }, j = g + a.size.outerHeight, k = this.cols + 1 - f.length, l = 0; k > l; l++) this.colYs[h + l] = j;
        return i;
    }, d.prototype._getColGroup = function(a) {
        if (2 > a) return this.colYs;
        for (var b = [], c = this.cols + 1 - a, d = 0; c > d; d++) {
            var e = this.colYs.slice(d, d + a);
            b[d] = Math.max.apply(Math, e);
        }
        return b;
    }, d.prototype._manageStamp = function(a) {
        var c = b(a), d = this._getElementOffset(a), e = this.options.isOriginLeft ? d.left : d.right, f = e + c.outerWidth, g = Math.floor(e / this.columnWidth);
        g = Math.max(0, g);
        var h = Math.floor(f / this.columnWidth);
        h -= f % this.columnWidth ? 0 : 1, h = Math.min(this.cols - 1, h);
        for (var i = (this.options.isOriginTop ? d.top : d.bottom) + c.outerHeight, j = g; h >= j; j++) this.colYs[j] = Math.max(i, this.colYs[j]);
    }, d.prototype._getContainerSize = function() {
        this.maxY = Math.max.apply(Math, this.colYs);
        var a = {
            height: this.maxY
        };
        return this.options.isFitWidth && (a.width = this._getContainerFitWidth()), a;
    }, d.prototype._getContainerFitWidth = function() {
        for (var a = 0, b = this.cols; --b && 0 === this.colYs[b]; ) a++;
        return (this.cols - a) * this.columnWidth - this.gutter;
    }, d.prototype.needsResizeLayout = function() {
        var a = this.containerWidth;
        return this.getContainerWidth(), a !== this.containerWidth;
    }, d;
});